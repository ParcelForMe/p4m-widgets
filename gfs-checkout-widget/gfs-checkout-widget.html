<link rel="import" href="../../polymer/polymer.html" />

<link rel="import" href="../p4m-spinner/p4m-spinner.html" />
<link rel="import" href="../../paper-toast/paper-toast.html" />
<link rel="import" href="../../paper-tabs/paper-tabs.html" />
<link rel="import" href="../../iron-pages/iron-pages.html" />
<link rel="import" href="../../iron-icons/iron-icons.html" />
<link rel="import" href="../../iron-dropdown/iron-dropdown.html" />
<link rel="import" href="../../paper-dropdown-menu/paper-dropdown-menu.html" />
<link rel="import" href="../../paper-item/paper-item.html">
<link rel="import" href="../../paper-listbox/paper-listbox.html">

<link rel="import" href="../gfs-droppoint/gfs-droppoint.html" />
<link rel="import" href="../gfs-droppoint/gfs-location-button.html" />
<link rel="import" href="../gfs-calendar/gfs-calendar.html" />
<link rel="import" href="../map-region-manager/map-region-manager.html" />

<script src="../../momentjs/min/moment.min.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAMQhcXM06TZBHZ95LwJBRVGSV4CqUQMpI&libraries=places"></script>
<link href="css/custom.css" rel="stylesheet" />
<link href="../gfs-shared/gfs.css" rel="stylesheet" />

<dom-module id="gfs-checkout">
    <!--<link rel="import" type="css" href="custom.css">-->

    <template>     

        <map-region-manager id="regionManager"></map-region-manager>

		<div id="widgetContainer">          
            <paper-tabs selected="{{selectedTab}}" no-bar>           
                <paper-tab id="calendardelivery_tab">{{calendarDeliveryTitle}}<p4m-spinner species="progress" id="calendar_spinner"></p4m-spinner></paper-tab>
                <paper-tab id="clickandcollect_tab">Click and Collect<p4m-spinner species="progress" id="clickandcollect_spinner"></p4m-spinner></paper-tab>
                <paper-tab id="standarddelivery_tab">{{standardDeliveryTitle}}<p4m-spinner species="progress" id="standarddelivery_spinner"></p4m-spinner></paper-tab>
            </paper-tabs>
            <iron-pages id="pages" selected="{{selectedTab}}"  on-iron-select="onSelectTab">           
                <iron-page id="pageCalendar">
                    <div id="calendar-loading" class="loading">
                        <p4m-spinner species="progress" id="calendar-spinner"></p4m-spinner>
                    </div>
                    <div class="pageContent horizontal layout">
                        <gfs-calendar id="calendar" class="flex" on-select-shipping-option="_selectCalendarShippingOption" day-definite-data="{{_data.dayDefinite}}"></gfs-calendar>
                    </div>
                </iron-page>
                <iron-page id="pageDroppoints">
                    <div id="availableDropPoints">
                        <div id="mapTools" class="pageContent">

                            <div class="toggleDropPointsViewControls">
                                <a id="viewAsMap" on-tap="_toggleDroppointView">
                                    <i class="p4micon p4micon-map-with-marker"></i>
                                </a>

                                <!-- <a id="viewAsList" on-tap="_toggleDroppointView">
                                    <i class="p4micon p4micon-list"></i>
                                </a> -->
                            </div>
    					
    					
                            <div class="location-points">
    							<paper-dropdown-menu label="My Locations" noink no-animations>
    								<paper-listbox class="dropdown-content">
    									    <paper-item >
                                                <gfs-location-button address-name="Current location" on-click="_locateMe" ></gfs-location-button>
                                            </paper-item>

    			                            <template id="myLocations" is="dom-repeat" items="{{_favAddresses}}" filter="hasLatLng">
                                                <paper-item label="{{item.name}}">
        			                                <gfs-location-button on-click="_onClickFavAddress" google-api-key="AIzaSyAMQhcXM06TZBHZ95LwJBRVGSV4CqUQMpI" address-name="{{item.name}}" address-data="{{item}}"></gfs-location-button>
                                                </paper-item>
    			                            </template>                                    
    									
    								</paper-listbox>
    							</paper-dropdown-menu>
    							
                            </div>
    						<div class="adjoiner"><p>or</p></div>
                          
                            <div class="search-postcode-wrap">
                                <address-lookup-field id="droppointAddress" on-foundplace="_panToPlace"></address-lookup-field>
                                <div type="submit" class="search-button" on-click="_panToPlaceOnClick"><iron-icon icon="icons:search"></iron-icon></div>
                            </div>

    						<div class="adjoiner"><p>or</p></div>
    							<div class="collection-points">
    								<paper-dropdown-menu label="My Collection Points" noink no-animations>
    									<paper-listbox class="dropdown-content">
    									   <template id="mapPreferredDropPointList" is="dom-repeat" items="{{_favDropPoints}}" sort="sortByDistance">
    					                     <paper-item label="{{item.droppointDescription}}">
        										<gfs-droppoint on-user-select="_selectFavDropPoint" on-droppoint-selected="_onDropPointSelectedEvent" container-class="" button-type="tick" disable-unchoose="true" droppoint-data="{{item}}" class="droppoint"></gfs-droppoint>
    	                            		 </paper-item>						
    									  </template>
    								   </paper-listbox>
    								</paper-dropdown-menu>
    							</div>
                            </div>


                            <div id="list-loading" class="loading">
                                <!-- <p4m-spinner species="shuffler" id="list-spinner"></p4m-spinner> -->
                                <p4m-spinner species="progress" id="list-spinner"></p4m-spinner>
                            </div>


                            <div class="page" id="pageDroppoints">

                            <div id="mapContainer">
                                <div class="hidden" id="hiddenElements">
                                    <div id="droppoint_info" class="noscroll">Selected</div>
                                    <div id="inspectingDropPointPanel">
                                        <gfs-droppoint id="inspectedDropPoint" droppoint-data="{{_inspectedDropPoint}}" show-shipping-options="false" show-distance="true" show-opening-hours="true"></gfs-droppoint>
                                    </div>
                                </div>                          
                                <!--
                                   <div id="gfsMapCanvas-loading" class="loading"><paper-spinner id="search-spinner"></paper-spinner></div> 
                                -->
                                <div id="mainMapArea">
                                    <div id="gfsMapCanvas">
                                        <div class="loading">
                                            <!-- <p4m-spinner species="shuffler" id="map-spinner"></p4m-spinner> -->
                                            <p4m-spinner species="progress" id="map-spinner"></p4m-spinner>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <array-selector id="dropPointSelector" items="{{_dropPoints}}" selected="{{selected}}" multi="false"></array-selector>
                            <div id="dropPointListContainer" class="hidden">
                                <div class="cardList">                           
                                    <div id="mainDropPointListArea">
                                        <div id="dropPointList">
                                            <template id="dropPointListTemplate" is="dom-repeat" items="{{_dropPoints}}" sort="sortByDistance" filter="filterToMap">
                                                <!-- <gfs-droppoint on-droppoint-selected="onDropPointSelectedEvent" show-shipping-options="true" show-opening-hours="true" show-distance="true" button-type="standard" droppoint-data="{{item}}" class="droppoint"></gfs-droppoint> -->
                                                <gfs-droppoint on-droppoint-selected="_onDropPointSelectedEvent" show-opening-hours="true" show-distance="true" button-type="standard" droppoint-data="{{item}}" class="droppoint"></gfs-droppoint>
                                            </template>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div id="selectedDropPointPanel" class="hidden" style="max-height: {{mapHeight}}px; display: block">
                                <gfs-droppoint id="infobox-droppoint" panel-mode="true" on-droppoint-selected="_onDropPointSelectedEvent" droppoint-data="{{_selectedDropPoint}}" on-user-select="_onLocateDroppointEvent" show-shipping-options="true" show-distance="true" show-opening-hours="true"></gfs-droppoint>
                            </div>
                            
                        </div>
                    </div>
                    <div id="noDropPoints" class="pageContent hidden">
                        <h2>Sorry</h2>
                        <p>There are no drop points available in your region</p>
                        <paper-item >
                            <gfs-location-button address-name="Current location" on-click="_setGfsLocationToHere" >Use my current location</gfs-location-button>
                        </paper-item>
                        <div class="search-postcode-wrap">
                            <address-lookup-field id="droppointAddress" on-foundplace="_panToPlace"></address-lookup-field>
                            <div type="submit" class="search-button" on-click="_panToPlaceOnClick"><iron-icon icon="icons:search"></iron-icon></div>
                        </div>

                    </div>

                </iron-page>
                <iron-page id="pageStandard">
                    <div id="standard-loading" class="loading">
                        <!-- <p4m-spinner species="shuffler" id="standard-spinner"></p4m-spinner> -->
                        <p4m-spinner species="progress" id="standard-spinner"></p4m-spinner>
                    </div>
                    <ul class="separated">
                        <template id="standardRatesTemplate" is="dom-repeat" items="{{standardRates}}">
                            <li class="gfsStd horizontal layout center">
                                <label for$="{{item.id}}">
                                    <p class="methodname lg">{{item.methodTitle}}</p>
                                    <p class="price lg">{{item.localizedPrice}}</p>
                                    <p class="deliveryDateRange">{{item.deliveryDateRange}}</p>
                                </label>
								<div class="flex"></div>
                                <i name="shipping_method" on-click="setDeliveryMethodEvent" value="{{item.id}}" id="{{item.id}}" class$="p4micon-check-circle link standard-delivery-selection selected_{{item._originalMethodObject.selected}}"></i>
                            </li>
                        </template>
                    </ul>
                </iron-page>
            </iron-pages>
        </div>
        <input type="text" value="{{_selectedDropPoint.droppointId}}" id="dropPointRadio" class="hidden" />
        <paper-toast id="errorNotification" class="fit-bottom"></paper-toast>

        <style include="p4m-shared">
            paper-tab {
                /*border-left: 1px solid rgba(116, 175, 131, 0.15);*/
                border-right: 1px solid rgba(255, 255, 255, .8);
                padding: 0;
            }
            paper-tab:first-of-type {
                border-left: none;
            }
            #dropPointList .content-container {
                padding: 0 0 1em 0;
                margin: .65em 1em;
                border-bottom: 2px solid #eaeaea;
            }
            #inspectingDropPointPanel {
                /*position: absolute;
                top: 327px !important;
                margin-top: -150px;
                left: 0;
                width: 100% !important;
                height: 150px !important;
                z-index: 9999;*/

                background: rgba(255,255,255,0.9) !important;
                padding: 15px !important;
                box-sizing: border-box;
            }
            #selectedDropPointPanel {
                position: absolute;
                height: auto;
                display: flex;
                flex: 2;
                padding: 10px;
                margin: 10px;
                background: rgba(255, 255, 255, 0.95);
                box-shadow: rgba(0, 0, 0, 0.3) 0px 1px 4px -1px; /* matches the Google Maps UI style */
                -webkit-transition: .2s ease-in-out;
                -moz-transition: .2s ease-in-out;
                transition: .2s ease-in-out;
            }
            .actions {
                margin-top: 5px;
            }
        </style>

    </template>

    <script>
        /* Warning message goes here */
        /*global Polymer*/
        var DAY_MS = 1000 * 60 * 60 * 24;
        var DOW_NAMES = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', '?'];
        var MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        // element registration
        Polymer({
            is: "gfs-checkout",

            // add properties and methods on the element's prototype

            properties: {
                //=== Element attributes ===//

                initialised: {
                    type: Boolean,
                    value: false
                },
                
                accessToken: {
                    type: String
                },

                currencySymbol: {
                    type: String,
                    value: '£'
                },

                config: {
                    type: Object
                },

                preselect: {
                    type: Object,
                    value: true
                },

                useDropPoints: {
                    type: Object,
                    value: true
                },

                useStandard: {
                    type: Object,
                    value: true
                },

                useCalendar: {
                    type: Object,
                    value: true
                },

                calendarLabels: {
                    type: Object,
                    value: {
                        //prev: "<<",
                        //next: ">>",
                        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                        weekdays: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                    }
                },

                allowCalendarPreselect: {
                    type: Object,
                    value: true
                },

                defaultTab: {
                    type: String //If 'calendar', shows calendar on startup
                },
/*
                defaultAddress: { //initialAddress
                    type: String
                },*/
               /*
                defaultPostCode: {
                    type: String
                },

                defaultCountryCode: {
                    type: String
                },*/


                // ATTRIBUTES
                //
                // These properties represent text used for labels, titles and prompts throughout the widget.
                // They are controlled by passing values via the element attributes.
                // To override the default values shown below, simply pass through the attributes name, with camel caps converted to dashed lower case:
                // e.g: 'dropPointTitle' would be set by:
                // <gfs-checkout drop-point-title="Your text goes here" ...

                dropPointTitle: {
                    type: String,
                    value: 'Would you prefer to collect your order?'
                },

                dropPointDeliveryTitle: {
                    type: String,
                    value: 'Select your preferred collection point to view available services:'
                },

                calendarDeliveryTitle: {
                    type: String,
                    value: 'Choose your day'
                },

                calendarDayPrompt: {
                    type: String,
                    value: 'Please select a delivery time:'
                },

                standardDeliveryTitle: {
                    type: String,
                    value: 'Standard Delivery'
                },
                
                hideMapUI: {
                    type: Object,
                    value: false
                },

                mapHeight: {
                    type: Number,
                    value: 400
                },

                homeIcon: {
                    type: String
                },

                markerIcon: {
                    type: String
                },

                selectedMarkerIcon: {
                    type: String
                },

                startingZoomLevel: {
                    type: Number,
                    value: 14
                },

                serviceSortOrder: {
                    type: String, //cheapestFirst, fastestFirst, expensiveFirst, slowestFirst
                    value: "cheapestFirst"
                },

                selectedTab: {
                    type: Number,
                    value: 0
                },

                mapIsReset: {
                    type: Boolean,
                    value: false
                },

                apiHost: {
                    type: String,
                    value: "rest-checkout.justshoutgfs.com"
                },


                // PRIVATE PROPERTIES
                //
                // Do not modify these properties.


                _suppliedSelection: {
                    type: Object
                },
                selectedServiceDetails: {
                    type: Object,
                    value: {
                        service: null,
                        serviceCode: null,
                        carrier: null,
                        shipping: null,
                        deliveryAddress: null,
                        expDeliveryDateStart: null,
                        expDeliveryDateEnd: null,
                        collectPoint: null
                    }
                },

                standardRates: {
                    type: Array,
                    value: []
                },

                _postData: {
                    type: Object,
                    value: {}
                },

                _autoChooseCollectionPoint: {
                    type: Object,
                    value: true
                },

                _selectedDropPoint: {
                    type: Object
                },

                _inspectedDropPoint: {
                    type: Object
                },             

                _dropPointDetailsClass: {
                    type: String,
                    value: "hidden"
                },

                _shippingRateGroups: {
                    type: Array,
                    notify: true,
                    value: []
                },

                _data: {
                    type: Object,
                    value: {
                        dayDefinite: [],
                        droppoints: [],
                        standardRates: [],
                        links: [],
                        nonDayDefinite: []
                    },
                    notify: true
                },

                _dropPoints: {
                    type: Array,
                    value: [],
                    notify: true
                },

                _favDropPoints: {
                    type: Array,
                    value: []
                },

                _favAddresses: {
                    type: Array,
                    value: [],
                    notify: true
                },

                _map: {
                    type: Object
                },

                _currentMarker: {
                    type: Object
                },

                _dropPointTickClass: {
                    type: String,
                    value: "notchosen"
                },

                _dropPointChooseBtnText: {
                    type: String,
                    value: "Choose"
                },

                _showingDroppoints: {
                    type: Object,
                    value: false
                },

                _showingDroppointsMap: {
                    type: Object,
                    value: true
                },

                _showingDroppointsList: {
                    type: Object,
                    value: false
                },

                _infoWindow: {
                    type: Object
                },

                //Lookup for deliveries on a given day
                _deliveryDays: {
                    type: Object,
                    value: {}
                },

                //Lookup for deliveries on a given day
                _deliveryDroppoints: {
                    type: Object,
                    value: {}
                },

                _earliestDelivery: {
                    type: Object,
                    value: null
                },

            },

            listeners: {
                "datetoggleon": "_deliveryDateSelected",
                "prevmonth": "_calendarMonthChanged",
                "nextmonth": "_calendarMonthChanged"
                //"droppoint-selected": "_onDropPointSelectedEvent"
            },

            // METHODS

            // This function is called as soon as the widget is ready
            ready: function () {
                console.log("GFS Checkout ready", new Date().getTime());
            },

            postGfsData: function (mapCenter, callback) {
                this._postReq(mapCenter, this._postData, callback);             
            },

            _makeRequest: function (method, url, callback) {
                if (!callback || typeof (callback) !== "function") {
                    throw "No callback";
                }

                if (this.accessToken === "") {
                    var error =  "No access token";
                    this.$.errorNotification = error;
                    this.$.errorNotification.show();
                    callback(error);
                }
                else {
                    var httpRequest = new XMLHttpRequest();
                    this._showAsLoading(true);

                    httpRequest.open(method, url, true);
                    this._attachHeaders(httpRequest, method);

                    httpRequest.onreadystatechange = (function () {
                        if (httpRequest.readyState !== XMLHttpRequest.DONE) {
                            this._showAsLoading(true);
                        }
                        else {
                            this._showAsLoading(false);
                            try {
                                if (httpRequest.status == 200 || httpRequest.status == 201) {
                                    callback(null, httpRequest.responseText);
                                }
                                else {
                                    //debugger;
                                    this.fire('noservice');
                                    console.error(httpRequest.responseText);
                                    //console.log("GFS error. Re-starting session.");    
                                    //this.postGfsData(callback);                     
                                    //callback(httpRequest.status, httpRequest.responseText);
                                }                                 
                            }
                            catch (e) {
                                console.error(e.stack);
                                callback(e);
                            }
                        }
                    }).bind(this);                   
                }
                return httpRequest;

            },

            _attachHeaders: function(httpReq, method) {
                var headers = this._computeHeader();
                for (var key in headers) {
                    httpReq.setRequestHeader(key, headers[key]);
                }
                httpReq.setRequestHeader('Content-Type', 'application/json');                
            },

            _computeHeader: function () {
                return {
                    "Authorization": "Bearer " + atob(this.accessToken)
                };
            },

            _postReq: function (mapCenter, data, callback) {
                if (typeof (callback) !== "function") {
                    throw "No callback provided";
                }
                var request = this._makeRequest('POST', "///"+this.apiHost+"/api/CheckoutSession",
                    ///rest-checkout.justshoutgfs.com/api/CheckoutSession/
                    (function (err, data) {
                        if (err) {
                            this.fire('noservice');
                            callback(err);
                        }
                        else {
                            //this.fire('noservice'); //DEBUG
                            if (!data) {
                                debugger;
                            }
                            this._getReq(mapCenter, data, (function (err) {
                                callback(err);
                            }).bind(this));
                        }
                    }).bind(this)
                );
                request.send(JSON.stringify(data));
            },

            _getReq: function (mapCenter, resourceUrl, callback) {
                var self = this;
                if (typeof (callback) !== "function") {
                    throw "No callback provided";
                }
                this._sessionId = resourceUrl.substring(resourceUrl.lastIndexOf("/") + 1).replace('"','');
                var url = "///"+this.apiHost+"/api/CheckoutSession/" + this._sessionId;
                var request = this._makeRequest('GET', url, (function (err, data) {

                    console.log("GFS Checkout GET response", new Date().getTime());

                    if (err) {
                        this.fire('noservice');
                        callback(err);
                    }
                    else {
                        var result = JSON.parse(data);
                        if (result.message) {
                            callback(result.message);
                        }
                        else {
                            this.set('_data', JSON.parse(data));
                            if (!this._dropPoints) {
                                this.set('_dropPoints', this._data.droppoints);
                            }
                            else {
                                var newDPs = this._data.droppoints.sort(this.sortByDistance);
                                this._dropPoints = this._dropPoints.concat(newDPs);
                            }
                            // record the region queried
                            /* "droppointSettings": {
                                "maxRadiusMeters": 5000,
                                "maxResults": 100,
                                "useDroppointDays": false   // use droppointDays property instead of collectionSlots?
                            },*/
                            this.$.regionManager.recordQuery(this.droppointSettings, mapCenter, this._data.droppoints);
                            this._processAllDroppoints();
                            this._requestDroppointList(this._favDropPoints, (function (err) {
                                this._delayedInit.bind(self)();
                                callback(err);
                            }).bind(this));
                        }

                    }
                }).bind(this));
                request.send("");
            },

            _closeReq: function (callback) {

                // temp hack to get around close session inconsistency
                if (this.selectedServiceDetails.collectionPoint) {
                    callback(null, "DPD"); // hard code the carrier to DPD for now
                    return;
                }

                var data = {
                    closeSession: true,
                    selectedDeliveryOptionId: this.selectedServiceDetails.serviceCode,
                    selectedDroppointId: this.selectedServiceDetails.collectionPoint || null
                };
              
                var request = this._makeRequest('PATCH', '///'+this.apiHost+'/api/CheckoutSession?sessionId=' + this._sessionId, (function (err, data) {

                    if (err) {
                        callback(err);
                    }
                    else {
                        var result = JSON.parse(data);
                        if (result.selectedService && result.selectedService.carrierName) {
                            callback(null, result.selectedService.carrierName);
                        }
                        else {
                            callback(null);
                        }
                    }
                }).bind(this));
                request.send(JSON.stringify(data));
            },

            _requestDroppointsByGeoBoxes: function (boxes, callback) {
                var self = this;
                var url = "///"+this.apiHost+"/api/CheckoutSession?sessionId=" + this._sessionId + "&regions=" + JSON.stringify(boxes);
                var request = this._makeRequest('GET', url, (function (err, data) {

                    var result = data?(JSON.parse(data)):{};
                    if (err || result.message) {
                        callback(err || result.message)
                    }
                    else {
                        if (result.droppoints && result.droppoints.length) {
                            this._dropPoints = this._dropPoints.concat(result.droppoints).sort(this.sortByDistance);
                            this._processAllDroppoints();
                            
                            this._loadDroppointMarkers(this._dropPoints);
                        }
                        callback(null);                     
                    }

                }).bind(this));
                request.send("");
            },

            setGfsOrderValue: function (value) {
                console.log('setGfsOrderValue(' + value + ')');
                this._postData.request.order.value.value = value;
            },

            //Put the address value into the GFS post data
            //TODO: Rename
            setGfsAddress: function (address, autoSelectDelivery, callback) {
                if (typeof (callback) !== "function") {
                    callback = function(){};
                }
                if (!address) {
                    callback("No address");
                }
                else {
                    //console.log('setGfsAddress(' + JSON.stringify(address) + ')');
                    this._postData.request.order.transit.recipient.location = address;
                    if (autoSelectDelivery) 
                        this.autoSelectDeliveryMethod(callback);
                    else
                        callback(null);
                }

            },

            setFavDropPoints: function (droppointList) {
                this._favDropPoints = droppointList;
                this._processFavDroppoints();
            },

            setFavAddresses: function (addressList) {
                this.set('_favAddresses', addressList);
            },

            selectFavAddress: function (address, callback) {
                // the user has selected a physical address for delivery so unselect any drop point - called from p4mCheckout
                this._unselectDropPoint();
                console.log(">>>Setting address", address);
                this.setMapHome({ 'lat': address.latitude, 'lng': address.longitude }, address.street1);
                this.setGfsAddress(address, true, callback);
            },


            requestDropPointsByAddress: function (address, callback) {
  
                var self = this;
                this._geoCodeAddress(address, function (err, data) {
                    if (!err && data) {
                        var box = [[data.lng - 0.01, data.lat - 0.01], [data.lng + 0.01, data.lat + 0.01]];
                        self._requestDroppointsByGeoBoxes([box], callback);
                    }
                    else {
                        console.error("Failed to locate address", err);
                        callback(err || "Failed to locate address");
                    }
                })
            },

            droppointSettings: {
                "maxRadiusMeters": 5000,
                "maxResults": 100,
                "useDroppointDays": false   // use droppointDays property instead of collectionSlots?
            },

            init: function (config, selection, finalCallback) {
                var self = this;
                this._suppliedSelection = selection;
                var requiredFields = [
                    'countryCode',
                    'postCode',
                    'town',
                    'addressLineCollection',
                    'contactEmail',
                    'recipientFirstName',
                    'recipientLastName',
                    'recipientTitle',
                    'cartValue',
                    //'addressPreferences',
                    'deliveryPreferences',
                    'favDropPoints',
                    'favAddresses',
                    'defaultAddress'
                ];
                var missingFields = requiredFields.filter(function (f) {
                    return (typeof (config[f]) == "undefined" || (config[f] == null));
                });
                if (missingFields.length) {
                    throw ("Missing fields: " + missingFields.toString());
                }
                else {
                    this.config = config;

                    //==== Create post data
                    var now = new Date();
                    var maxDate = new Date(now.getTime() + (1000 * 60 * 60 * 24 * 14));

                    this._postData = {
                        "request":
                        {
                            "dateRange": {
                                "dateFrom": this._makeDateStr(now),
                                "dateTo": this._makeDateStr(maxDate)
                            },

                            "droppointSettings": this.droppointSettings,

                            "order": {
                                "transit": {
                                    "recipient": {
                                        "location": {
                                            "countryCode": {
                                                "code":  config.countryCode,
                                                "encoding": "ccISO_3166_1_Alpha2"
                                            },
                                            "postCode": config.postCode,
                                            "town": config.town,
                                            "county": config.state,
                                            "addressLineCollection": config.addressLineCollection
                                        },
                                        "contactDetails": {
                                            "email": config.contactEmail
                                        },
                                        "person": {
                                            "firstName": config.recipientFirstName,
                                            "lastName": config.recipientLastName,
                                            "title": config.recipientTitle || "Mr"
                                        }
                                    }
                                },
                                "value": {
                                    "currencyCode": "GBP",
                                    "value": config.cartValue
                                }
                            },
                            "requestedDeliveryTypes": ["dmDropPoint", "dmStandard"],
                            "session": { "sessionID": "" }
                        }
                    };

                    if (selection && selection.address) {
                        var location = this._postData.request.order.transit.recipient.location;
                        location.CountryCode = selection.address.CountryCode;
                        location.Postcode = selection.address.Postcode;
                        location.town = selection.address.town || "";
                        location.addressLineCollection = selection.address.addressLineCollection;
                    }

                    //==== Set fav address data
                    this.setFavDropPoints(this.config.favDropPoints); 
                    this.setFavAddresses(this.config.favAddresses);

                    //if everything has been preselected, preselect,
                    if (selection && selection.deliveryMethodId) {
                        //Post, then try to re-select the chosen method
                        this.postGfsData(config.mapCenter, function (err) {
                            this.initialised = true;
                            if (!err) {
                                if (selection.dropPointId) {
                                    self._completeDropPointSelection(selection.dropPointId, selection.deliveryMethodId, finalCallback);
                                }
                                else {
                                    var res = self.setDeliveryMethod(selection.deliveryMethodId, selection.deliveryDate);
                                    if (res)
                                        finalCallback();
                                    else {
                                        // the methodId could not be found in the new methods list so auto select something
                                        self.runDeliveryAddressPreferences(self.config.addressPreferences, self.config.defaultAddress, function (err) {
                                            if (err) {
                                                console.error("postGfsData() returned", err);
                                                finalCallback(err);
                                            }
                                            else {
                                                self.autoSelectDeliveryMethod(finalCallback);
                                            }
                                        });
                                    }
                                }
                            }
                            else finalCallback(err);
                        });
                    }
                    //Otherwise auto-select address and delivery method according to preferences (if any)
                    else {
                        //Set delivery address first. This will then trigger auto-setting of delivery method
                        this.runDeliveryAddressPreferences(this.config.addressPreferences, this.config.defaultAddress, function (err) {
                            self.postGfsData(self.config.mapCenter, function(err) {
                                this.initialised = true;
                                if (err) {
                                    console.error("postGfsData() returned", err);
                                    finalCallback(err);
                                }
                                else
                                {
                                    self.autoSelectDeliveryMethod(finalCallback);
                                }
                            });
                        });
                    }                 
                }
            },

            //Assuming an address has been chosen, choose a delivery method that best suits the user's preferences:
            //preferSoonest: true/false
            //
            autoSelectDeliveryMethod: function (callback) {
                //If the address chosen is a droppoint,
                //   Get the delivery methods on the droppoint
                //   Choose the most preferred
                //Else if the address chosen isn't a droppoint,
                //   Choose the most preferred standard delivery
                if (!this.standardRates.length) {
                    callback(null); //No delivery methods available yet                    
                }
                else {
                    if (this.config.deliveryPreferences) {
                        var sortFunction = this._getDeliveryMethodSortFunction();
                        if (this._selectedDropPoint) {
                            //this._selectedDropPoint.deliveries = this._selectedDropPoint.deliveries.sort(sortFunction);
                            //this.set('_selectedDropPoint.deliveryMethod',this._selectedDropPoint.deliveries[0].service.id);
                            //this.setDeliveryMethod();
                            
                            //Can I get away without selecting it via the droppoint widget?
                            this.$['infobox-droppoint'].selectMethod(this._selectedDropPoint.deliveries[0].service.id); //This should send the selection back as a droppoint-selected event
                            this.showPage_Droppoints();
                        }
                        else if (this.config.deliveryPreferences.preferSoonest) {
                            this.setDeliveryMethod(this._data.dayDefinite[0]);
                            this.showPage_Calendar();
                        }
                        else {
                            this.standardRates = this.standardRates.sort(sortFunction);
                            this.setDeliveryMethod(this.standardRates[0].id);
                            this.showPage_Standard();
                        }
                        callback(null);
                    }
                    else {
                        console.warn("No delivery preferences - autoselecting without them");
                        if (this._selectedDropPoint) {
                            this.setDeliveryMethod(this._selectedDropPoint.deliveries[0].service.id);
                        }
                        else {
                            this.setDeliveryMethod(this.standardRates[0].id);
                        }
                        callback(null);
                    }                   
                }
            },

            //Assuming a delivery method has been chosen, choose a delivery address
            autoSelectDeliveryAddress: function (serviceDetails) {
                //If it's a standard delivery method, choose default fav address
                //newSelectedServiceDetails
                if (serviceDetails.serviceType.type == "dmStandard") {
                    this.setGfsAddress(this.config.defaultAddress);
                }
                else {
                    //If it's a droppoint delivery method....?
                    //TODO
                }
            },

            //Select a delivery address based on the users preferences
            runDeliveryAddressPreferences: function(prefs, defaultAddress, finalCallback) {

                //Select address based on preferences
                var defaultPrefs = ["useMyDeliveryAddress", "useMyDropPoints", "useRetailerDropPoint"];
                if (!prefs || prefs.constructor !== Array) {
                    console.log("runDeliveryAddressPreferences: using default", defaultPrefs);
                    prefs = defaultPrefs;
                }

                //Preferred address
                //Process a priority list of address preferences
                var self = this;
                var handlers = {
                    "useMyDeliveryAddress": function (callback) { self.setGfsAddress(defaultAddress, true, callback); },
                    "useMyDropPoints": function (callback) { self.selectNearestFavDropPoint(callback); },
                    "useRetailerDropPoint": function (callback) { self.selectNearestDropPoint(callback); }
                };
                var handlerArray = [];
                prefs.forEach(function (pref) {
                    handlerArray.push(handlers[pref]);
                });

                function runHandler(index) {
                    handler = handlerArray[index || 0];
                    if (handler) {
                        //console.log("Running handler", index);
                        handler(function (err, data) {
                            //console.log("Handler returned", err);
                            if (err) {
                                runHandler(index + 1);
                            }
                            else {
                                finalCallback();
                            }
                        });
                    }
                    else {
                        finalCallback();
                        //console.log("Finished running handlers");
                    }
                }

                runHandler(0);

            },

            _preselectForCalendar: function () {
                //this.$.calendar.autoSelect();
            },

            //TODO: Change to use _originalShippingService.selected
            _preselectForStandard: function () {
                /*
                //TODO This function needs to change
                if (this.standardRates) {
                    //this.set('_selectedDropPoint', null);
                    this._unselectDropPoint();
                    var preselectedService = this.standardRates[0];
                    if (!preselectedService.selected) {
                        preselectedService.selected = true;
                    }                   
                    
                    this.setDeliveryMethod(preselectedService.id, preselectedService.deliveryDate);
                    this.set('standardRates', JSON.parse(JSON.stringify(this.standardRates)));
                    this.$.standardRatesTemplate.render();
                    //this.fire('selectedservicechanged', this.selectedServiceDetails);//.standardRates[0]);
                    //this.fire('preselectedservice', this.selectedServiceDetails);
                }*/

            },

            //Select a delivery service
            //TODO: Refactor?
            setDeliveryMethod: function (methodId, dateOverride) {

                if (!methodId) {
                    debugger;
                    return;
                }

                var newMethod = this._getDeliveryRateById(methodId);
                if (!newMethod) {
                    debugger;
                    console.error("Method not available");
                    //this.fire('noservice');
                    return;
                }

                else {
                    //The original service object is attached directly to selectedServiceDetails, allowing us to deselect it directly
                    if (this.selectedServiceDetails && this.selectedServiceDetails._originalMethodObject) {
                        this.selectedServiceDetails._originalMethodObject.selected = false;
                    }

                    newMethod.selected = true;
                    //if (!newMethod.price) {
                    //}

                    var newSelectedServiceDetails = {
                        _originalMethodObject: newMethod,
                        serviceId: methodId,
                        service: newMethod.methodTitle,
                        serviceCode: newMethod.deliveryOptionId,
                        carrier: newMethod.carrierName,
                        shipping: newMethod.price,
                        currencySymbol: this.currencySymbol
                    }

                    if (dateOverride) {
                        newSelectedServiceDetails.expDeliveryDate = moment.utc(dateOverride).toISOString();
                        this.$.calendar.selectShippingOption(methodId, dateOverride, true);
                    }
                    else {
                        this.$.calendar.selectShippingOption(null, null, true);
                        newSelectedServiceDetails.expDeliveryDate = moment.utc(newMethod.deliveryTimeTo).add(newMethod.maxDD - newMethod.minDD, 'days').toISOString();
                    }

                    if (newMethod.serviceType.type == "dmStandardDropPoint" && this._selectedDropPoint)
                    {
                        newSelectedServiceDetails.collectionPoint = this._selectedDropPoint.droppointId;
                        newSelectedServiceDetails.companyName = this._selectedDropPoint.droppointDescription;
                        newSelectedServiceDetails.providerId = this._selectedDropPoint.providerId;
                        newSelectedServiceDetails.provider = this._selectedDropPoint.providerName;
                        newSelectedServiceDetails.deliveryAddress = this._selectedDropPoint.geoLocation;
                        this.set('_selectedDropPoint.deliveryMethod', methodId);
                    }
                    else {

                        //If we have selected something other than a droppoint, and we previously had a droppoint selected,
                        //We need to unselected it and then auto-select a standard address
                        if (this._selectedDropPoint) {
                            this._unselectDropPoint(); //If unselect a droppoint, default back to a fav address
                            this.autoSelectDeliveryAddress(newMethod); //This is a reference to the original delivery method object                           
                        }
                        else {
                            //We had a standard address selected already, apparently. 
                            //So we don't need to autoselect one.
                            console.log("Not selecting a standard address automatically.")
                        }
                        newSelectedServiceDetails.deliveryAddress = this._postData.request.order.transit.recipient.location;
                    }
                    this.set('selectedServiceDetails', newSelectedServiceDetails);                  

                    this.set('standardRates', this._getStandardServices());

                    this.$.standardRatesTemplate.render();
                    this.fire('selectedservicechanged', this.selectedServiceDetails);
                    this._updateUi();
                    return this.selectedServiceDetails;
                }
            },
                        
            selectNearestFavDropPoint: function(callback) {
                if (this._favDropPoints.length) {
                    this._selectDropPoint(this._favDropPoints[0].droppointId, callback);
                }
                else {
                    callback("No favourite drop-points");
                }
            },

            selectNearestDropPoint: function (callback) {
                if (this._sessionId) {
                    self = this;
                    this.requestDropPointsByAddress(this.config.defaultAddress, function (dropPoints) {
                        if (dropPoints && dropPoints.length) {
                            var dropPoint = dropPoints[0];
                            self._selectDropPoint(dropPoint.droppointId, callback);
                        }
                        else {
                            callback("No supported drop-points found");
                        }
                    });
                }
                else
                    callback();
            },

            //This runs after the GFS requests have returned data
            _delayedInit: function () {
                this._processRateData();

                if (this.useDropPoints) {
                    this._makeMap();
                    this._processAllDroppoints();
                }
            },

            //Index and tidy GFS rate data
            _processRateData: function () {
                if (this._data.nonDayDefinite.constructor === Array && this._data.nonDayDefinite.length > 0) {
                    this._data.standardRates = this._getStandardServices();
                    this.set('standardRates', this._data.standardRates);
                    //console.log(this.standardRates);
                }
                this.notifyPath('_data.dayDefinite'); //??? Needed?
            },

            _showAsLoading: function (loading) {

                if (loading) {
                    this.$$('#list-spinner').active = "true";
                    this.$$('#standard-spinner').active = "true";
                    this.$$('#list-loading').classList.remove('hidden');
                    this.$$('#standard-loading').classList.remove('hidden');
                    this.$$('#calendar-loading').classList.remove('hidden');
                }
                else {
                    this.$$('#list-spinner').active = null;
                    this.$$('#standard-spinner').active = null;
                    this.$$('#list-loading').classList.add('hidden');
                    this.$$('#standard-loading').classList.add('hidden');
                    this.$$('#calendar-loading').classList.add('hidden');
                }
            },


            sortByDistance: function (a, b) {
                if (a.selected) return -1
                else if (b.selected) return 1
                else if (a === b) return 0;
                else return a.distanceInMeters < b.distanceInMeters ? -1 : 1;
            },

            filterToMap: function (item) {
                if (this._map) {
                    if (this._mapViewPort) {
                        var sw = { longitude: this._mapViewPort[0][0], latitude: this._mapViewPort[0][1] };
                        var ne = { longitude: this._mapViewPort[1][0], latitude: this._mapViewPort[1][1] };

                        if ((item.geoLocation.coordinates.latitude > sw.latitude && item.geoLocation.coordinates.latitude < ne.latitude)
                            && (item.geoLocation.coordinates.longitude > sw.longitude && item.geoLocation.coordinates.longitude < ne.longitude)) {
                            return true;
                        }
                        else {
                            return false;
                        }                      
                    }
                    else return true;
                }
                else {
                    return true;
                }              
            },
            /*
            getClosestDroppoint: function (dpList) {
                return dpList.reduce(function (prev, curr) {
                    return (prev.distanceMeters < curr.distanceInMeters) ? prev : curr;
                });
            },*/

            _getDeliveryMethodSortFunction: function() {

                if (this.config.deliveryPreferences.preferSoonest) {
                    return (
                        function(a, b) {
                            if (a && b) {
                                return a.deliveryTimeFrom || a.deliveryDate < b.deliveryTimeFrom || a.deliveryDate ? 1 : -1;
                            }
                            else {
                                console.warn("Sorting by deliveryDate: invalid parameter: ", a, b);
                                return 1;
                            }
                            
                        }
                    );
                }
                else {
                    return (
                        function(a, b) {

                            if (a && b) {
                                if (a.service && b.service) {
                                    aPrice = a.service.price;
                                    bPrice = a.service.price;
                                }
                                else {
                                    aPrice = a.price;
                                    bPrice = b.price;
                                }  
                                return aPrice > bPrice? 1 : -1;
                                                            
                            }
                            else {
                                console.warn("Sorting by price: invalid parameter: ", a, b);
                                return 1;
                            }
                           
                        }
                    );
                }
            },
            
            _processAllDroppoints: function () {
                this._removeDupDropPoints();
                this._addDropPointDeliveries();
                this._sortDropPointServices();
                this._processFavDroppoints();
                this._indexDropPointProviders(this._data.dayDefinite);
                this._indexDropPointProviders(this._data.nonDayDefinite);
            },

            _removeDupDropPoints: function () {
                var self = this;
                var uniques = [];
                for (var j = 0; j < this._dropPoints.length; j++) {
                    var dp = this._dropPoints[j];
                    if (!uniques.find(function(item) {
                        return item.droppointId == dp.droppointId;
                    })) {
                        uniques.push(dp);
                    }
                }
                this.set('_dropPoints', uniques);
            },

            _sortDropPointServices: function() {
                if (this.config.deliveryPreferences) {
                    var sortFunction = this._getDeliveryMethodSortFunction();
                    this._dropPoints.map(
                        function(item) {
                            if (item.deliveries && item.deliveries.length) {
                                item.deliveries = item.deliveries.sort(sortFunction);
                            }                           
                        });
                    
                }
            },

            _addDropPointDeliveries: function () {
                var self = this;
                this._dropPoints.map(
                    function (item) {

                        item.collectionPoint = true;
                        item.deliveries = self._findDropPointDeliveries(item.providerId);
                        return item;
                    }
                );
            },

            _processFavDroppoints: function()
            {
                //Now replace preferred items with real data
                var self = this;
                this._favDropPoints = this._favDropPoints.map(function (item) {
                    var existingItem = self._droppointById(item.droppointId);
                    if (existingItem) {
                        existingItem.selected = item.selected;
                    }
                    return existingItem || item;
                }).sort(this.sortByDistance);
            },
            
            _makeMap: function () {
                var self = this;

                var home = null;
                var imgSrc = this.resolveUrl('images/gmap-icon-selected-shadow-32px.png');
                var imgTag = '<img src="' + imgSrc + '" style="position:relative;top:40px;left:12px;">';
                self._infoWindow = new google.maps.InfoWindow({
                    //TIP: To use dynamic content here, use "droppoint_info" as shown in comment below. Then place a droppoint widget or similar into the droppoint_info element.
                    content: imgTag
                });

                /* The infoWindow is the place marker attached to the currently selected drop point
                 * The google.maps.event.addListener() event waits for
                 * the creation of the infowindow HTML structure 'domready'
                 * and before the opening of the infowindow defined styles
                 * are applied.
                 */
                google.maps.event.addListener(self._infoWindow, 'domready', function () {
                    // Reference to the DIV which receives the contents of the infowindow using jQuery
                    var iwOuter = document.getElementsByClassName('gm-style-iw')[0];
                    iwOuter.style.overflow = 'visible';
                    // the white bkg and shadow are grouped in the prev element
                    iwOuter.previousSibling.style.display = 'none';
                    // reduce the size of the non-clickable area created by the info window
                    iwOuter.parentElement.style.width = 0;
                    // remove the scroll bars from the img parent divs
                    iwOuter.firstChild.style.overflow = 'visible';
                    iwOuter.firstChild.firstChild.style.overflow = 'visible';
                    // hide the close button
                    iwOuter.nextSibling.style.display = 'none';
                });

                var position = new google.maps.LatLng(37, 0);

                // map options
                var mapOptions = {

                    // initial zoom level
                    zoom: self.startingZoomLevel,
                    minZoom: self.startingZoomLevel - 2,

                    // initial center position
                    center: position,

                    // type of map (ROADMAP, SATELLITE, TERRAIN, HYBRID)
                    mapTypeId: google.maps.MapTypeId.TERRAIN,

                    // show or hide streetview control
                    streetViewControl: false,

                    // show or hide the google map UI
                    disableDefaultUI: self.hideMapUI,

                    // map controls (only if disableDefaultUI is false)
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
                        position: google.maps.ControlPosition.TOP_RIGHT,
                    },

                    zoomControlOptions: {
                        style: google.maps.ZoomControlStyle.SMALL,
                        position: google.maps.ControlPosition.TOP_RIGHT
                    },

                    // remove points of interest from the map so as not to interfere
                    styles: [{
                        "featureType": "poi",
                        "elementType": "labels",
                        "stylers": [{
                            "visibility": "off"
                        }]
                    }]
                };

                //var postcode = document.getElementById('shipping:postcode').value; //Improve selection method

                self._map = new google.maps.Map(self.$.gfsMapCanvas, mapOptions);
                window.map = self._map;            

                // 'idle' event is triggered when the user stopped zooming/dragging;
                google.maps.event.addListener(self._map, 'idle', function (event) {
                    //console.log(JSON.stringify(event));
                    //console.log('MAP EVENT idle');
                    self._mapMoved();
                });

                //google.maps.event.addListener(self._map, 'click', function (event) {
                    //console.log('MAP EVENT click');
                    //self._unselectDropPoint();
                //});

                //google.maps.event.addListener(self._map, 'center_changed', function (event) {
                    //console.log('MAP EVENT center_changed');
                    //self._unselectDropPoint();
                //});

            },

            _loadDroppointMarkers: function (dropPointsArray) {
                var self = this;
                if (!dropPointsArray) return;
                //=== Drop point markers
                var marker;
                dropPointsArray.forEach(
					function (pointItem) {
					    if (true || !pointItem.marker) {
					        var getCountryCode = pointItem.geoLocation.countryCode;
					        var markerConfig = {
					            position: new google.maps.LatLng(pointItem.geoLocation.coordinates.latitude, pointItem.geoLocation.coordinates.longitude),
					            map: self._map,
					            //animation: google.maps.Animation.DROP,
					            //title: pointItem.droppointDescription,
					            customData: pointItem,
					            icon: self._droppointIcon(getCountryCode) + '/' + pointItem.providerName.toLowerCase() + '.png',
					            zIndex: google.maps.Marker.MAX_ZINDEX + 1
					            //icon: url + '/' + pointItem.geoLocation.countryCode + '/' + pointItem.providerName + '.png'
					        };
					        //console.log(pointItem.geoLocation.coordinates.longitude, pointItem.geoLocation.coordinates.latitude);
					        marker = new google.maps.Marker(markerConfig);
					        marker.addListener('click', function (clickedMarker) {
					            self._selectDropPointMarker(this);
					        });
					        marker.addListener('mouseover', function (inspectedMarker) {
					            var latlng = this.getPosition();
					            self._inspectDropPointMarker(this);
					        });
					        marker.addListener('mouseout', function () {
					            self._hideDropPointInspector();
					        });
					        // add a link to the marker to get to it from the droppoint, need to animate and centre the marker if selecting from list view
					        pointItem.marker = marker;
					    }
					}
				);
                this.$.dropPointListTemplate.render();

            },

            _droppointIcon: function(countryCode) {
                var url = this.resolveUrl('./images/');
                if (!countryCode) {
                    return url;
                }
                else {                
                    switch (countryCode) {
                    case "DE":
                        return url + 'de';
                    case "FR":
                    case "BE":
                    case "ES":
                        return url + 'fr';
                    default:
                        return url + 'gb';
                    }
                }
            },

            _geoCodeAddress: function (address, callback) {
                if (address.lat && address.lng) {
                    callback(null, { 'lat': address.lat, 'lng': address.lng });
                    return;
                }
                if (!address.addressLineCollection || address.addressLineCollection.length == 0) {
                    callback("No results");
                    return;
                }
                var addressStr = address.addressLineCollection[0] + "," + address.postCode;
                var geocoder = new google.maps.Geocoder();
                geocoder.geocode({
                    componentRestrictions: {
                        country: address.countryCode.code || this.countryCode
                    },
                    address: addressStr
                },
                function (results, status) {
                    if (status == google.maps.GeocoderStatus.OK) {
                        if (results && results.length) {
                            var geoLocation = results[0].geometry.location;
                            callback(null, { 'lat': geoLocation.lat(), 'lng': geoLocation.lng() });
                        }
                    }
                    else {
                        callback("No results");
                    }
                });
            },

            _mapMoved: function() {
                var self = this;
                if (self._moveMapTimeout) {
                    window.clearTimeout(self._moveMapTimeout);
                }
                self._moveMapTimeout = window.setTimeout((function() {
                    self._reloadDroppoints();
                }).bind(this), 100);

            },

            // used for trouble shooting
            _drawBoxes: function(boxes, color) {
                var self = this;
                boxes.forEach(function(rect) {
                    var boxCoords = [{
                        lat: rect[0][1],
                        lng: rect[0][0]
                    }, // north west
                        {
                            lat: rect[0][1],
                            lng: rect[1][0]
                        }, // south west
                        {
                            lat: rect[1][1],
                            lng: rect[1][0]
                        }, // south east
                        {
                            lat: rect[1][1],
                            lng: rect[0][0]
                        } // north east
                    ]

                    self._map.data.setStyle({
                        fillColor: color,
                        strokeColor: color,
                        strokeWeight: 2
                    });
                    self._map.data.add({
                        geometry: new google.maps.Data.Polygon([boxCoords])
                    });
                });
            },

            _updateMapViewPort: function() {
                var bounds = this._map.getBounds();
                if (!bounds) {
                    console.error("Failed to get map bounds");
                    return;
                }          
                var northEast = [bounds.getNorthEast().lng(), bounds.getNorthEast().lat()];
                var southWest = [bounds.getSouthWest().lng(), bounds.getSouthWest().lat()];
                if (northEast[0] === southWest[0] && northEast[1] === southWest[1]) return;
                this._mapViewPort = [southWest, northEast];
            },

            _updateUi: function() {
                //Display/hide things based on the current state

                if (this._selectedDropPoint) {
                    this.$.selectedDropPointPanel.classList.remove("hidden");
                }
                else {
                    this.$.selectedDropPointPanel.classList.add("hidden");
                }
                this.$.dropPointListTemplate.render(); //Re-sort the list of drop point cards
            },

            
            _reloadDroppoints: function() {
                if (this._sessionId) {
                    //console.log('reloadDroppoints()');

                    //Get viewport rectangle
                    this._updateMapViewPort();
                    if (!this._mapViewPort) return;

                    var boxes = [];
                    
                    this.$.regionManager.getUncoveredRectangles(this._mapViewPort).forEach(function (rect) {
                        boxes.push(rect.toGeoBox());
                    });

                    // console.log('Boxes to request:', JSON.stringify(boxes));
                    // self._drawBoxes(boxes, 'green');
                    
                    if (boxes.length > 0 && this._mapViewPort) {
                        this.$.regionManager.addRegion(this._mapViewPort);
                        this._requestDroppointsByGeoBoxes(boxes, function () { });
                    }
                    else {
                        console.log("Not requesting any regions");
                    }                    
                    this._resetMap(this._map);
                }
            },

            _requestDroppointList: function (droppointList, callback) {
                //NOTE: This is temporary code, to be replaced by a dedicated API endpoint
                if (droppointList.length === 0) {
                    callback();
                }
                else {
                    var self = this;

                    //Make array of geoBoxes, tightly encompassing each droppoint
                    var boxes = [];
                    droppointList.forEach(function (dp) {
                        boxes.push([[dp.geoLocation.coordinates.longitude - 0.000001, dp.geoLocation.coordinates.latitude - 0.000001], [dp.geoLocation.coordinates.longitude + 0.000001, dp.geoLocation.coordinates.latitude + 0.000001]]);
                    });
                    this._requestDroppointsByGeoBoxes(boxes, callback);
                }

            },

            _showDropPointDetails: function() {
                this.mapHeight = this.$.gfsMapCanvas.clientHeight;
                this._dropPointDetailsClass = "fade-in";
            },

            _toggleDroppointView: function() {
                this._showingDroppointsList = !this._showingDroppointsList;
                this._showingDroppointsMap = !this._showingDroppointsMap;
                this._showDropPointsView();
            },

            _showDropPointsView: function () {
                var self = this;
                //this.fire('show-droppoints');
                if (this._showingDroppointsMap) {
                    //Show droppoints
                    this.$.dropPointListContainer.classList.add('hidden');
                    this.$.mapContainer.classList.remove('hidden');
                    //this._makeMap();
                    this._loadDroppointMarkers(this._dropPoints);                                                                           
                    this._resetMap(this._map, function() {
                        self._openSelectedDropPointInfoWindow();
                        if (!self._currentMarker)
                            self.panToDefaultLocation();
                        // Switch classes on the Map/list toggle - help BAZ!
                        self.$.viewAsMap.classList.add('active');
                        //self.$.viewAsList.classList.remove('active');
                    });
                }
                else {
                    this.$.dropPointListContainer.classList.remove('hidden');
                    this.$.mapContainer.classList.add('hidden');
                    // Switch classes on the Map/list toggle_sel
                    this.$.viewAsMap.classList.remove('active');
                    //this.$.viewAsList.classList.add('active');
                }

            },

            CheckMapIsReset: function () {
                if (this._map && !this.mapIsReset) {
                    var self = this;
                    this._resetMap(this._map, function () {
                        self.panToDefaultLocation();
                        if (self._currentMarker)
                            self._infoWindow.open(self._map, self._currentMarker);
                        self.mapIsReset = true;
                    });
                }
            },

            _resetMap: function (map, callback) {
                var self = this;
                if (map) {
                    window.setTimeout(function () {
                        google.maps.event.trigger(map, 'resize');
                        if (callback) callback();
                    }, 100);
                }           
            },

            _getHomeIcon: function() {
                if (this.homeIcon) {
                    return this.homeIcon;
                } else {
                    return this.resolveUrl('./images/home.png');
                }
            },

            _openSelectedDropPointInfoWindow: function () {
                if (this._showingDroppointsMap && this._selectedDropPoint) {
                    var dp = this._droppointById(this._selectedDropPoint.droppointId);
                    
                    if (dp) {
                        if (this._currentMarker == dp.marker) return;
                        else this._currentMarker = dp.marker;
                    }
                   
                    this.$.dropPointRadio.setAttribute('checked', 'true');
                    if (!this._infoWindow.attachedTo || this._infoWindow.attachedTo !== this._currentMarker.customData.droppointId) {
                        this._infoWindow.open(this._map, this._currentMarker);
                        this._infoWindow.attachedTo = this._currentMarker.customData.droppointId;
                    }
                    this._map.panTo(this._currentMarker.getPosition());
                }
            },

            _onLocateDroppointEvent: function (e) {
                // the user has clicked on the selected drop point panel so we will pan it to the center of the map
                this.panToDefaultLocation();
            },

            //=== Received event from droppoint widget, indicating that a delivery method from a droppoint has been chosen
            //Note that this doesn't fire just when a droppoint is clicked on, or when selected is set to true;
            //To fire, it must be selected AND a delivery method chosen.
            //
            //Make this droppoint the 'selected' one, and open the info window
            _onDropPointSelectedEvent: function (e) {
                if (!e.detail.deliveryMethod) {
                    console.log("No delivery method chosen.");
                }

                //.if (this._selectedDropPoint && this._selectedDropPoint.droppointId == e.detail.droppointId) return; //Already selected
                //If there is no method, _completeDropPointSelection will choose one for us
                var self = this;
                //Get selected delivery method
                this._completeDropPointSelection(e.detail.droppointId, e.detail.deliveryMethod, function () {

                    //Show on the map, pop up the info window
                    self._openSelectedDropPointInfoWindow();
                    self._updateUi();

                });

            },

            //==== Make this droppoint the 'selected' one
            //If no method chosen, auto-choose one
            _completeDropPointSelection: function(droppointId, methodId, callback) {
                if (!callback) { callback = function () { }; }
                this.showPage_Droppoints();
                var self = this;
                if (methodId && (methodId == this.selectedServiceDetails.serviceId && this.selectedServiceDetails.collectionPoint == droppointId) ) {
                    callback(null); 
                } 
                else {
                    var dp = this._droppointById(droppointId)            
                    this.set("_selectedDropPoint", dp);
                    this.set("_selectedDropPoint.selected", true);
                    if (methodId) {    
                        //If we're selecting a new droppoint and/or method,
                        this.$['infobox-droppoint'].select();
                        this.$['infobox-droppoint'].selectMethod(methodId, true);      
                        this.setDeliveryMethod(methodId);    
                        self._updateUi(); 
                        callback(null);
                    }
                    else {
                        this.autoSelectDeliveryMethod(function (err) {
                            self._updateUi();
                            callback(err);
                        });
                    }
                }
            },

            _selectDropPoint(dropPointId) {
                var self = this;
                this._completeDropPointSelection(dropPointId, null, function () {
                    self.$['infobox-droppoint'].select(); //The gfs-droppoint widget will fire droppoint-selected 
                    //Next stop _onDropPointSelectedEvent() 
                })
            },

            //=== Select a drop point marker
            //Make it the 'selected' one
            //Select the infobox's gfs-droppoint widget.
            _selectDropPointMarker: function (marker) {
                //var dp = this._droppointById(null, marker.customData.droppointId);
                //marker.setIcon('/scripts/lib/p4m-widgets/p4m-shared/img/gmap-icon-selected-shadow-32px.png');
                this._selectDropPoint(marker.customData.droppointId);
            },

            _inspectDropPointMarker: function (marker) {
                var dp = this._droppointById(marker.customData.droppointId);
                this._inspectDropPoint(dp, marker);
            },

            _inspectDropPoint: function (dp, marker) {
                this._hideDropPointInspector();

                this._inspectDropPointTimeout = window.setTimeout((function() {
                    this.set('_inspectedDropPoint', dp);
                    this.$.inspectedDropPoint.buildWeekCollection();
                    this._hideDropPointInspector();


                    this._customInfoBox = new InfoBox({
                        latlng: marker.getPosition(),
                        map: this._map,
                        content: this.$.inspectingDropPointPanel
                    });       
                }).bind(this), 350);


            },

            _hideDropPointInspector: function() {
                if (this._inspectDropPointTimeout) {
                    window.clearTimeout(this._inspectDropPointTimeout);
                    delete this._inspectDropPointTimeout;
                }
                if (this._customInfoBox) {
                    this._customInfoBox.remove();

                    this._customInfoBox = null;
                    this.set('_inspectedDropPoint', null);
                }
            },


            _selectFavDropPoint: function (e) {
                // has this drop point been queried for?
                var dpId = e.target.droppointData.droppointId;
                var dp = this._droppointById(dpId);
                if (!dp) {
                    // check the fav DPs
                    var self = this;
                    for (var i = 0; i < this._favDropPoints.length; i++) {
                        if (this._favDropPoints[i].droppointId === dpId) {
                            // if we get here it means the user has selected a fav DP that is not in a queried region
                            dp = this._favDropPoints[i];
                            var addr = { lat: dp.geoLocation.coordinates.latitude, lng: dp.geoLocation.coordinates.longitude };
                            this.requestDropPointsByAddress(addr, function () {
                                self._selectDropPoint(dpId);
                            });
                        }
                    }
                }
                else
                    this._selectDropPoint(dpId);
            },

            _unselectDropPoint: function () {
                if (this._selectedDropPoint) {
                    if (this._infoWindow) {
                        this._infoWindow.attachedTo = null;
                        this._infoWindow.close();
                    }
                    //this._hideDropPointDetails();
                    this._updateUi();
                    this._selectedDropPoint = null;
                    this._currentMarker = null;
                }
            },
           
            _droppointById: function (droppointId) {
                if (this._dropPoints) 
                    for (var i = 0; i < this._dropPoints.length; i++) 
                        if (this._dropPoints[i].droppointId === droppointId) 
                            return this._dropPoints[i];
            },

            _locateMe: function(callback) {
                var self = this;
                // Try HTML5 geolocation.
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        function(position) {
                            var pos = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            };
                            self._panToGeoLocation(pos);
                        },
                        function(err) {
                            if (callback) {
                                callback(err, pos);
                            }
                            console.error(JSON.stringify(err));
                        }
                    );
                } 
                else {
                    console.error("Browser does not support geolocation");

                }
            },

            _setGfsLocationToHere: function() {
                /*var self = this;
                this._locateMe(function(err, latlng) {
                    if (err) {
                        //zzzz
                    }
                    else {
                        //TODO: Reverse geolocate latlng to address, then pass the country and postcode
                        var geocoder = new google.maps.Geocoder;
                         geocoder.geocode({'location': latlng}, function(results, status) {
                            console.log(result);
                            //Now extract the post code and country, set it the GFS address, and post it to GFS
                
                            self.setGfsAddress({
                                location: {
                                    countryCode: "",
                                    postCode: ""
                                }
                            });
                           self.postGfsData();
                        });

                    }
                });*/
            },

            setMapHome: function (location, label) {
                if (!label)
                    label = 'Home';
                var homeMarkerConfig = {
                    position: location,
                    map: this._map,
                    //animation: google.maps.Animation.DROP,
                    title: label,
                    html: label,
                    icon: this._getHomeIcon()
                };
                marker = new google.maps.Marker(homeMarkerConfig);
                this.currentMapCenter = location;
                //this._map.setCenter(homeMarkerConfig.position);
            },

            currentMapCenter: null,
            panToDefaultLocation: function () {
                var self = this;
                if (this._currentMarker) {
                    self._infoWindow.open(self._map, self._currentMarker);
                    self._panToGeoLocation(this._currentMarker.getPosition());
                }
                else if (this.currentMapCenter) {
                    self._panToGeoLocation(this.currentMapCenter);
                }
                else if (this._postData.request.order.transit.recipient.location) {
                    var loc = this._postData.request.order.transit.recipient.location;
                    this._geoCodeAddress(loc, function (err, data) {
                        if (err)
                            console.error('panToDefaultLocation():', err);
                        else {
                            self.setMapHome(data, loc.addressLineCollection[0]);
                            self._panToGeoLocation(data);
                        }
                    });
                }
                else if (this._favAddresses.length) {
                    if (this._favAddresses[0].geoLocation.coordinates.latitude && this._favAddresses[0].geoLocation.coordinates.longitude) {
                        var geoLocation = {
                            lat: this._favAddresses[0].geoLocation.coordinates.latitude,
                            lng: this._favAddresses[0].geoLocation.coordinates.longitude
                        };
                        this.setMapHome(geoLocation, this._favAddresses[0].addressLineCollection[0]);
                        this._panToGeoLocation(geoLocation);
                    }
                }
            },


            _makeDateStr: function(d) {
                function pad(n, padSize) {
                    var str = n.toString();
                    var padZeros = (new Array(padSize)).join('0');
                    return (padZeros + str).substr(-padSize);
                }
                return (
                    pad(d.getFullYear(), 4) + '-' +
                    pad(d.getMonth() + 1, 2) + '-' +
                    pad(d.getDate(d), 2)
                );
            },

            _selectCalendarShippingOption: function (e) {
                //console.log('Updating delivery options with', e.detail.shippingMethodId, e.detail.deliveryDate);
                this.setDeliveryMethod(e.detail.shippingMethodId, e.detail.deliveryDate);
            },

            _formatDayDefiniteDate: function(deliveryDate) {
                return '(Est. arrival: ' + moment(deliveryDate).format("ddd, Do MMM") + ')';
            },

            _formatNonDayDefiniteDate: function(startDate, endDate) {
                return '(Est. arrival: ' + moment(startDate).format("ddd, Do MMM") + ' - ' + moment(endDate).format("ddd, Do MMM") + ')';
            },

            _findDropPointDeliveries: function(providerId) {
                var self = this;
                //var droppointIndex = providerId;
                if (typeof (this._deliveryDroppoints[providerId]) !== "undefined") {
                    var results = [];
                    for (var service in this._deliveryDroppoints[providerId]) {
                        var item = this._deliveryDroppoints[providerId][service];
                        /*var obj = {
                            id: item.service.id,
                            methodTitle: item.service.methodTitle,
                            price: item.service.price,
                        };*/
                        if (item.service.maxDD == item.service.minDD) {
                            // day definite
                            var startDate = new Date(item.deliveryDate);
                            item.deliveryDateRange = this._formatDayDefiniteDate(startDate);
                        }
                        else {
                            // non day definite
                            var startDate = new Date(item.deliveryDate);
                            var endDate = new Date(startDate);
                            endDate.setDate(endDate.getDate() + (item.service.maxDD - 1));
                            item.deliveryDateRange = this._formatNonDayDefiniteDate(startDate, endDate);
                        }
                        results.push(item);
                    }
                    return results;
                } else {
                    return null;
                }
            },

            //Make a lookup for droppoint providers, allowing all shipping methods for that provider to be returned
            _indexDropPointProviders: function (deliveryDayArray) {
                var self = this;
                //For each item in the array of delivery days,
                deliveryDayArray.forEach(function (day) {
                    //For each rate on the day,
                    day.rates.forEach(function (service) {
                        //If this is a droppoint,
                        if (service.serviceType.type === "dmStandardDropPoint") {
                            //For each droppoint provider that covers this droppoint,
                            service.serviceType.droppointProviders.forEach(function (provider) {                              
                                //If this is a provider not yet seen, instantiate with a blank object
                                if (typeof (self._deliveryDroppoints[provider.id]) === "undefined") {
                                    self._deliveryDroppoints[provider.id] = {};
                                }
                                //If this is a service not known for this provider, add it    
                                if (typeof(self._deliveryDroppoints[provider.id][service.id]) === "undefined") {
                                    self._deliveryDroppoints[provider.id][service.id] = {
                                        deliveryDate: day.deliveryDate,
                                        service: service
                                    };
                                }
                                //Else if this is a known service for this provider,
                                else {
                                    //If this new one has an earlier delivery date, use that one
                                	var oldDay = new Date(self._deliveryDroppoints[provider.id][service.id].deliveryDate);
                                	var thisDay = new Date(day.deliveryDate);
                                	if (oldDay.getTime() > thisDay.getTime()) {
                                        self._deliveryDroppoints[provider.id][service.id] = {
                                            deliveryDate: day.deliveryDate,
                                            service: service
                                        };
                                    }
                                }
                            });
                        }
                    });
                });
            },

            // find the earliest of each non-day-definite service
            _getStandardServices: function () {
                var self = this;
                var results = [];
                var services = {};

                //For each non day definite item,
                this._data.nonDayDefinite.forEach(function (day) {
                    //For each rate on the day,
                    day.rates.forEach(function (serviceItem) {
                        //If this is a standard rate,
                        if (serviceItem.serviceType.type === "dmStandard") {
                            //If this is a provider not yet seen, instantiate 
                            if (typeof (services[serviceItem.id]) === "undefined") {
                                services[serviceItem.id] = {
                                    deliveryDate: day.deliveryDate,
                                    service: serviceItem
                                };
                            }                         
                            //If this new one has an earlier delivery date, use that one
                            var oldDay = new Date(services[serviceItem.id].deliveryDate);
                            var thisDay = new Date(day.deliveryDate);
                            if (oldDay > thisDay) {
                                services[serviceItem.id].deliveryDate = day.deliveryDate;
                            }
                            services[serviceItem.id].selected = services[serviceItem.id].selected || serviceItem.selected;
                        }
                    });
                });

                //Now convert the index into an array
                for (var service in services) {
                    var item = services[service];
                    var obj = {
                        id: item.service.id,
                        methodTitle: item.service.methodTitle,
                        price: item.service.price,
                        localizedPrice: item.service.localizedPrice,
                        _originalMethodObject: item.service
                    };
                    // non day definite
                    var startDate = new Date(item.deliveryDate);
                    var endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + (item.service.maxDD - 1));
                    obj.deliveryDateRange = this._formatNonDayDefiniteDate(startDate, endDate);
                    obj.deliveryTimeFrom = endDate.getTime();
                    results.push(obj);
                }

                if (this.config.deliveryPreferences) {
                    var sortFunction = this._getDeliveryMethodSortFunction();
                    results = results.sort(sortFunction);
                }
                return results;
            },
            
            _getDeliveryRateById: function (id) {
                var combinedRateGroups = this._data.dayDefinite.concat(this._data.nonDayDefinite);
                var rates = [];
                combinedRateGroups.forEach(function (group) {
                    rates = rates.concat(group.rates);
                });
                var resultList = rates.filter(function (rate) {
                    return rate.id == id
                });
                if (resultList.length) {
                    return resultList[0];
                }
                else return null;
            },

            _unselectMethod: function() {
                var methods = this.standardRates;
                methods.forEach(function (item) {
                    item.selected = false;
                });
            },

          
            setDeliveryMethodEvent: function (e) {
                //if (e.target.checked) {                    
                    this.setDeliveryMethod(e.target.id);
                //}
            },

            onSelectTab: function (e) {
                if (e.detail.item.id === "pageCalendar") {
                    this.onShowPage_Calendar();
                }
                else if (e.detail.item.id === "pageStandard") {
                    this.onShowPage_Standard();
                }
                else if (e.detail.item.id === "pageDroppoints") {
                    this.onShowPage_Droppoints();
                }
                else {
                }
            },

            showPage_Calendar: function() {              
                this.$.pages.select(0);
                this.onShowPage_Calendar();              
            },

            onShowPage_Calendar: function(preselect) {
                this.showingDroppoints = false;
            },

            showPage_Standard: function (preselect) {
                this.$.pages.select(2)           
			},

			onShowPage_Standard: function(preselect) {
			    this.showingDroppoints = false;
  			    this.$.standardRatesTemplate.render();
			},

			showPage_Droppoints: function () {
			    if (this.$.pages.selected !== 1) {
			        this.$.pages.select(1);
			        this.onShowPage_Droppoints();
			    }
            },

            onShowPage_Droppoints: function() {
            	if (this._map) {
                    this.showingDroppoints = true;
                    this._showDropPointsView();
                }
            },

			showView_DroppointsList: function() {

			},

			_onClickDroppoint: function (e) {

			},

			_onClickFavAddress: function (e) {
			    var addr = e.currentTarget;
			    var loc = addr.geoLocation;
			    this.setMapHome(loc, addr.addressData.addressLineCollection[0]);
			    this._panToGeoLocation(loc);
			},
            /*
			_onSelectFavDroppoint: function (dp) {
			    var geoLocation = {
			        lat: dp.currentTarget.droppointData.geoLocation.coordinates.latitude,
			        lng: dp.currentTarget.droppointData.geoLocation.coordinates.longitude
			    };
			    this._panToGeoLocation(geoLocation);
			},*/

			_panToGeoLocation: function (geoLocation) {
                this._map.panTo(geoLocation);
                this._mapViewPort = [[ geoLocation.lng - 0.01,geoLocation.lat - 0.01], [geoLocation.lng + 0.01, geoLocation.lat + 0.01]];
			},

			_panToPlace: function (e) {
			    var loc = { 'lat': e.detail.geometry.location.lat(), 'lng': e.detail.geometry.location.lng() };
			    this.setMapHome(loc, e.detail.name);
			    this._panToGeoLocation(loc);
            },

            addressLookupLocation: null,
			_panToPlaceOnClick: function (e) {
			    var addr = this.addressLookupLocation;
			    if (addr) {
			        var loc = { 'lat': addr.lat(), 'lng': addr.lng() };
			        this._panToGeoLocation(loc);
			        this.currentMapCenter = loc;
			    }
			},

            enableClickAndCollect: function(enable) {
                enable = true; //TODO: Forcing on for the time being. Remove this line when the travelling user UI is to be finished.
                if (enable) {
                    this.$.availableDropPoints.classList.remove('hidden');
                    this.$.noDropPoints.classList.add('hidden');
  
                }
                else {
                    this.$.availableDropPoints.classList.add('hidden');
                    this.$.noDropPoints.classList.remove('hidden');
                }
            },

            enableCalendarDelivery: function(enable) {
                if (enable) {
                    this.$.calendardelivery_tab.classList.remove('hidden');
                }
                else {
                    this.$.calendardelivery_tab.classList.add('hidden');
                }
            },
            
            hasLatLng: function (item) {
                //return true;
                return (item.lat && item.lng)
            }
        });

        function isNull(a, b) {
            if (a == null || typeof (a) == "undefined" || a == "" || a.length == 0) return b
            else return a;
        }


        /* An InfoBox is like an info window, but it displays
         * under the marker, opens quicker, and has flexible styling.
         * @param {GLatLng} latlng Point to place bar at
         * @param {Map} map The map on which to display this InfoBox.
         * @param {Object} opts Passes configuration options - content,
         * offsetVertical, offsetHorizontal, className, height, width
         */

        function InfoBox(opts) {
            google.maps.OverlayView.call(this);
            this.latlng_ = opts.latlng;
            this.map_ = opts.map;
            this.content = opts.content;
            this.contentOrigin = this.content.parentNode;
            this.offsetVertical_ = -195;
            this.offsetHorizontal_ = 5;
            //this.height_ = 165;
            this.width_ = 240;

            this.setMap(this.map_);
        }
        /* InfoBox extends GOverlay class from the Google Maps API
         */
        InfoBox.prototype = new google.maps.OverlayView();
        /* Creates the DIV representing this InfoBox
         */
        InfoBox.prototype.remove = function () {
            if (this.content) {
                this.contentOrigin.appendChild(this.content);
            }
            this.setMap(null);
        };
        /* Redraw the Bar based on the current projection and zoom level
         */
        InfoBox.prototype.draw = function () {
            // Creates the element if it doesn't exist already.
            this.createElement();
            if (!this.content) return;
            // Calculate the DIV coordinates of two opposite corners of our bounds to
            // get the size and position of our Bar
            var pixPosition = this.getProjection().fromLatLngToDivPixel(this.latlng_);
            if (!pixPosition) return;

            var posX = pixPosition.x + this.offsetHorizontal_;
            var posY = pixPosition.y + this.offsetVertical_ + 85;//- (this.height_/2);

            // Now position our DIV based on the DIV coordinates of our bounds
            this.content.style.width = this.width_ + "px";
            this.content.style.left = (posX - 32) + "px";
            this.content.style.height = this.height_ + "px";
            this.content.style.top = (posY + 70) + "px";
            this.content.style.display = 'block';
            this.content.style.position = 'relative';
            
            this.content.style['z-index'] = 99;
        };

        InfoBox.prototype.createElement = function () {
            var panes = this.getPanes();
            panes.floatPane.appendChild(this.content);
        }

    </script>
</dom-module>
<link rel="import" href="../../polymer/polymer.html" />

<link rel="import" href="../p4m-spinner/p4m-spinner.html" />
<link rel="import" href="../../paper-toast/paper-toast.html" />
<link rel="import" href="../../paper-tabs/paper-tabs.html" />
<link rel="import" href="../../iron-pages/iron-pages.html" />
<link rel="import" href="../../iron-icons/iron-icons.html" />
<link rel="import" href="../../iron-dropdown/iron-dropdown.html" />
<link rel="import" href="../../paper-dropdown-menu/paper-dropdown-menu.html" />
<link rel="import" href="../../paper-item/paper-item.html">
<link rel="import" href="../../paper-listbox/paper-listbox.html">

<link rel="import" href="../gfs-droppoint/gfs-droppoint.html" />
<link rel="import" href="../gfs-droppoint/gfs-location-button.html" />
<link rel="import" href="../gfs-calendar/gfs-calendar.html" />
<link rel="import" href="../map-region-manager/map-region-manager.html" />

<script src="../../momentjs/min/moment.min.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAMQhcXM06TZBHZ95LwJBRVGSV4CqUQMpI&libraries=places"></script>
<link href="css/custom.css" rel="stylesheet" />
<link href="../gfs-shared/gfs.css" rel="stylesheet" />

<dom-module id="gfs-checkout">
    <!--<link rel="import" type="css" href="custom.css">-->

    <template>     

        <map-region-manager id="regionManager"></map-region-manager>

		<div id="widgetContainer">          
            <paper-tabs selected="{{selectedTab}}" no-bar>           
                <paper-tab id="calendardelivery_tab">{{calendarDeliveryTitle}}<p4m-spinner species="progress" id="calendar_spinner"></p4m-spinner></paper-tab>
                <paper-tab id="clickandcollect_tab">Click and Collect<p4m-spinner species="progress" id="clickandcollect_spinner"></p4m-spinner></paper-tab>
                <paper-tab id="standarddelivery_tab">{{standardDeliveryTitle}}<p4m-spinner species="progress" id="standarddelivery_spinner"></p4m-spinner></paper-tab>
            </paper-tabs>
            <iron-pages id="pages" selected="{{selectedTab}}"  on-iron-select="onSelectTab">           
                <iron-page id="pageCalendar">
                    <div id="calendar-loading" class="loading">
                        <p4m-spinner species="progress" id="calendar-spinner"></p4m-spinner>
                    </div>
                    <div class="pageContent horizontal layout">
                        <gfs-calendar id="calendar" class="flex" on-select-shipping-option="_selectCalendarShippingOption" day-definite-data="{{_data.dayDefinite}}"></gfs-calendar>
                    </div>
                </iron-page>
                <iron-page id="pageDroppoints">
                    <div id="availableDropPoints">
                        <div id="mapTools" class="pageContent">
                            <!--
                            <div class="toggleDropPointsViewControls">
                                <a id="viewAsMap" on-tap="_toggleDroppointView">
                                    <i class="p4micon p4micon-map-with-marker"></i>
                                </a>

                                <a id="viewAsList" on-tap="_toggleDroppointView">
                                    <i class="p4micon p4micon-list"></i>
                                </a>
                            </div>  
                            -->  					
    					
                            <div class="location-points">
    						    <paper-dropdown-menu label="My Locations" noink no-animations>
    							    <paper-listbox class="dropdown-content">
    									    <paper-item >
                                                <gfs-location-button address-name="Current location" on-click="_locateMe" ></gfs-location-button>
                                            </paper-item>

    			                            <template id="myLocations" is="dom-repeat" items="{{_favAddresses}}" filter="hasLatLng">
                                                <paper-item label="{{item.name}}">
        			                                <gfs-location-button on-click="_onClickFavAddress" google-api-key="AIzaSyAMQhcXM06TZBHZ95LwJBRVGSV4CqUQMpI" address-name="{{item.name}}" address-data="{{item}}"></gfs-location-button>
                                                </paper-item>
    			                            </template>                                    
    									
    							    </paper-listbox>
    						    </paper-dropdown-menu>
    							
                            </div>
    					    <div class="adjoiner"><p>or</p></div>
                          
                            <div class="search-postcode-wrap">
                                <address-lookup-field id="droppointAddress" on-foundplace="_panToPlace"></address-lookup-field>
                                <div type="submit" class="search-button" on-click="_panToPlaceOnClick"><iron-icon icon="icons:search"></iron-icon></div>
                            </div>

    					    <div class="adjoiner"><p>or</p></div>
    						<div class="collection-points">
    							<paper-dropdown-menu label="My Collection Points" noink no-animations>
    								<paper-listbox class="dropdown-content">
    									<template id="mapPreferredDropPointList" is="dom-repeat" items="{{_favDropPoints}}">
    					                    <paper-item label="{{item.droppointDescription}}">
        									<gfs-droppoint on-user-select="_selectFavDropPoint" droppoint-data="{{item}}" class="droppoint" container-class="preferredList"></gfs-droppoint>
    	                            		</paper-item>						
    									</template>
    								</paper-listbox>
    							</paper-dropdown-menu>
    						</div>
                        </div>

                        <div id="list-loading" class="loading">
                            <!-- <p4m-spinner species="shuffler" id="list-spinner"></p4m-spinner> -->
                            <p4m-spinner species="progress" id="list-spinner"></p4m-spinner>
                        </div>

                        <div class="page" id="pageDroppoints">

                            <array-selector id="dropPointSelector" items="{{_dropPoints}}" selected="{{selected}}" multi="false"></array-selector>
                            <div id="dropPointListContainer">
                                <div id="dpListScroller" class="cardList" style="height:{{mapHeight}}px!important;">
                                    <div id="mainDropPointListArea">
                                        <div id="dropPointList">
                                            <template id="dropPointListTemplate" is="dom-repeat" items="{{_dropPoints}}" sort="sortDropPoints">
                                                <gfs-droppoint panel-mode="true" on-user-select="_onDropPointSelectedEvent" droppoint-data="{{item}}" class="droppoint"></gfs-droppoint>
                                            </template>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div id="mapContainer">
                                <div class="hidden" id="hiddenElements">
                                    <div id="droppoint_info" class="noscroll">Selected</div>
                                    <div id="inspectingDropPointPanel">
                                        <gfs-droppoint id="inspectedDropPoint" droppoint-data="{{_inspectedDropPoint}}" show-shipping-options="false" show-distance="true" show-opening-hours="true"></gfs-droppoint>
                                    </div>
                                </div>                          
                                <!--
                                    <div id="gfsMapCanvas-loading" class="loading"><paper-spinner id="search-spinner"></paper-spinner></div> 
                                -->
                                <div id="mainMapArea">
                                    <div id="gfsMapCanvas">
                                        <div class="loading">
                                            <!-- <p4m-spinner species="shuffler" id="map-spinner"></p4m-spinner> -->
                                            <p4m-spinner species="progress" id="map-spinner"></p4m-spinner>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!--
                            <div id="selectedDropPointPanel" class="hidden" style="max-height: {{mapHeight}}px; display: none">
                                <gfs-droppoint id="infobox_droppoint" panel-mode="true" on-droppoint-selected="_onDropPointSelectedEvent" droppoint-data="{{_selectedDropPoint}}" on-user-select="_onLocateDroppointEvent" show-shipping-options="true" show-distance="true" show-opening-hours="true"></gfs-droppoint>
                            </div>-->                            
                        </div>
                    </div>
                    <div id="noDropPoints" class="pageContent hidden">
                        <h2>Sorry</h2>
                        <p>There are no drop points available in your region</p>
                        <paper-item >
                            <gfs-location-button address-name="Current location" on-click="_locateMe" >Use my current location</gfs-location-button>
                        </paper-item>
                        <div class="search-postcode-wrap">
                            <address-lookup-field id="droppointAddress" on-foundplace="_panToPlace"></address-lookup-field>
                            <div type="submit" class="search-button" on-click="_panToPlaceOnClick"><iron-icon icon="icons:search"></iron-icon></div>
                        </div>

                    </div>

                </iron-page>
                <iron-page id="pageStandard">
                    <div id="standard-loading" class="loading">
                        <!-- <p4m-spinner species="shuffler" id="standard-spinner"></p4m-spinner> -->
                        <p4m-spinner species="progress" id="standard-spinner"></p4m-spinner>
                    </div>
                    <ul class="separated">
                        <template id="standardRatesTemplate" is="dom-repeat" items="{{standardRates}}">
                            <li class="gfsStd horizontal layout center">
                                <label for$="{{item.id}}">
                                    <p class="methodname lg">{{item.methodTitle}}</p>
                                    <p class="price lg">{{item.localizedPrice}}</p>
                                    <p class="deliveryDateRange">{{item.deliveryDateRange}}</p>
                                </label>
								<div class="flex"></div>
                                <i name="shipping_method" on-click="setDeliveryMethodEvent" value="{{item.id}}" id="{{item.id}}" class$="p4micon-check-circle link standard-delivery-selection selected_{{item._originalMethodObject.selected}}"></i>
                            </li>
                        </template>
                    </ul>
                </iron-page>
            </iron-pages>
        </div>
        <input type="text" value="{{_selectedDropPoint.droppointId}}" id="dropPointRadio" class="hidden" />
        <paper-toast id="errorNotification" class="fit-bottom"></paper-toast>

        <style include="p4m-shared">
            paper-tab {
                /*border-left: 1px solid rgba(116, 175, 131, 0.15);*/
                border-right: 1px solid rgba(255, 255, 255, .8);
                padding: 0;
            }
            paper-tab:first-of-type {
                border-left: none;
            }
            #dropPointList .content-container {
                padding: 0 0 1em 0;
                margin: .65em 1em;
                border-bottom: 2px solid #eaeaea;
            }
            #dropPointList {
                display: flex;
                height: 100%;
                overflow-y: scroll;
                flex-wrap: wrap;
            }
            #inspectingDropPointPanel {
                /*position: absolute;
                top: 327px !important;
                margin-top: -150px;
                left: 0;
                width: 100% !important;
                height: 150px !important;
                z-index: 9999;*/

                background: rgba(255,255,255,0.9) !important;
                padding: 15px !important;
                box-sizing: border-box;
            }
            #dropPointListContainer {
                max-width: 270px;
                display: flex;
                align-self: stretch;
                height: initial;
            }
            .cardList {
                display: flex;
            }
            #selectedDropPointPanel {
                position: absolute;
                height: auto;
                display: none;
                flex: 2;
                padding: 10px;
                margin: 10px;
                background: rgba(255, 255, 255, 0.95);
                box-shadow: rgba(0, 0, 0, 0.3) 0px 1px 4px -1px; /* matches the Google Maps UI style */
                -webkit-transition: .2s ease-in-out;
                -moz-transition: .2s ease-in-out;
                transition: .2s ease-in-out;
            }
            .actions {
                margin-top: 5px;
            }

            .pinned {
                position: absolute;
                top: 0;
                z-index: 2;
                background: white;
                min-width: 253px!important;
                width: 253px!important;
                border-bottom: 1px solid #aaa;
            }
            .pinned:after {
                content:"";
                position:absolute;
                width:100%;
                height: 5px;
                background: linear-gradient(#ccc, rgba(250, 250, 250, 0.39));
                bottom:-6px;
                z-index:1;
            }
        </style>

    </template>

    <script>
        /* Warning message goes here */
        /*global Polymer*/
        var DAY_MS = 1000 * 60 * 60 * 24;
        var DOW_NAMES = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', '?'];
        var MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        // element registration
        Polymer({
            is: "gfs-checkout",

            // add properties and methods on the element's prototype

            properties: {
                //=== Element attributes ===//

                initialised: {
                    type: Boolean,
                    value: false
                },
                
                accessToken: {
                    type: String
                },

                currencySymbol: {
                    type: String,
                    value: '£'
                },

                config: {
                    type: Object
                },

                preselect: {
                    type: Object,
                    value: true
                },

                useDropPoints: {
                    type: Object,
                    value: true
                },

                useStandard: {
                    type: Object,
                    value: true
                },

                useCalendar: {
                    type: Object,
                    value: true
                },

                calendarLabels: {
                    type: Object,
                    value: {
                        //prev: "<<",
                        //next: ">>",
                        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                        weekdays: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                    }
                },

                allowCalendarPreselect: {
                    type: Object,
                    value: true
                },

                defaultTab: {
                    type: String //If 'calendar', shows calendar on startup
                },
/*
                defaultAddress: { //initialAddress
                    type: String
                },*/
               /*
                defaultPostCode: {
                    type: String
                },

                defaultCountryCode: {
                    type: String
                },*/


                // ATTRIBUTES
                //
                // These properties represent text used for labels, titles and prompts throughout the widget.
                // They are controlled by passing values via the element attributes.
                // To override the default values shown below, simply pass through the attributes name, with camel caps converted to dashed lower case:
                // e.g: 'dropPointTitle' would be set by:
                // <gfs-checkout drop-point-title="Your text goes here" ...

                dropPointTitle: {
                    type: String,
                    value: 'Would you prefer to collect your order?'
                },

                dropPointDeliveryTitle: {
                    type: String,
                    value: 'Select your preferred collection point to view available services:'
                },

                calendarDeliveryTitle: {
                    type: String,
                    value: 'Choose your day'
                },

                calendarDayPrompt: {
                    type: String,
                    value: 'Please select a delivery time:'
                },

                standardDeliveryTitle: {
                    type: String,
                    value: 'Standard Delivery'
                },
                
                hideMapUI: {
                    type: Object,
                    value: false
                },

                mapHeight: {
                    type: Number,
                    value: 400
                },

                homeIcon: {
                    type: String
                },

                markerIcon: {
                    type: String
                },

                selectedMarkerIcon: {
                    type: String
                },

                startingZoomLevel: {
                    type: Number,
                    value: 14
                },

                serviceSortOrder: {
                    type: String, //cheapestFirst, fastestFirst, expensiveFirst, slowestFirst
                    value: "cheapestFirst"
                },

                selectedTab: {
                    type: Number,
                    value: 0
                },

                mapIsReset: {
                    type: Boolean,
                    value: false
                },

                apiHost: {
                    type: String,
                    value: "rest-checkout.justshoutgfs.com"
                },


                // PRIVATE PROPERTIES
                //
                // Do not modify these properties.


                _suppliedSelection: {
                    type: Object
                },
                selectedServiceDetails: {
                    type: Object,
                    value: {
                        service: null,
                        serviceCode: null,
                        carrier: null,
                        shipping: null,
                        deliveryAddress: null,
                        expDeliveryDateStart: null,
                        expDeliveryDateEnd: null,
                        collectPoint: null
                    }
                },

                standardRates: {
                    type: Array,
                    value: []
                },

                _postData: {
                    type: Object,
                    value: {}
                },

                _autoChooseCollectionPoint: {
                    type: Object,
                    value: true
                },

                _selectedDropPoint: {
                    type: Object
                },

                _inspectedDropPoint: {
                    type: Object
                },             

                _dropPointDetailsClass: {
                    type: String,
                    value: "hidden"
                },

                _shippingRateGroups: {
                    type: Array,
                    notify: true,
                    value: []
                },

                _data: {
                    type: Object,
                    value: {
                        dayDefinite: [],
                        droppoints: [],
                        standardRates: [],
                        links: [],
                        nonDayDefinite: []
                    },
                    notify: true
                },

                _dropPoints: {
                    type: Array,
                    value: [],
                    notify: true
                },

                _favDropPoints: {
                    type: Array,
                    value: []
                },

                _favAddresses: {
                    type: Array,
                    value: [],
                    notify: true
                },

                _map: {
                    type: Object
                },

                _currentMarker: {
                    type: Object
                },

                _dropPointTickClass: {
                    type: String,
                    value: "notchosen"
                },

                _dropPointChooseBtnText: {
                    type: String,
                    value: "Choose"
                },

                _showingDroppoints: {
                    type: Object,
                    value: false
                },

                _showingDroppointsMap: {
                    type: Object,
                    value: true
                },

                _infoWindow: {
                    type: Object
                },

                //Lookup for deliveries on a given day
                _deliveryDays: {
                    type: Object,
                    value: {}
                },

                //Lookup for deliveries on a given day
                _deliveryDroppoints: {
                    type: Object,
                    value: {}
                },

                _earliestDelivery: {
                    type: Object,
                    value: null
                },

            },

            listeners: {
                "datetoggleon": "_deliveryDateSelected",
                "prevmonth": "_calendarMonthChanged",
                "nextmonth": "_calendarMonthChanged",
                "dropPointList.scroll": "dpListScrolled"
                //"droppoint-selected": "_onDropPointSelectedEvent"
            },

            // METHODS

            // This function is called as soon as the widget is ready
            ready: function () {
                console.log("GFS Checkout ready", new Date().getTime());
            },

            postGfsData: function (mapCenter, callback) {
                this.currentMapCenter = null;   // setting this to null will move the map when it is displayed
                this._postReq(mapCenter, this._postData, callback);             
            },

            _topDPPinned: false,
            _topDPWasExpanded: false,
            dpListScrolled: function (event) {
                // scrolling the DP list - keep the selected DP visible at the top of the list
                if (this._selectedDropPoint) {
                    var dpCard = this.$.dropPointList.firstElementChild;
                    if (this._topDPPinned && this.$.dropPointList.scrollTop < 10) {
                        dpCard.classList.remove('pinned');
                        this._topDPPinned = false;
                        if (this._topDPWasExpanded && !dpCard.expanded)
                            dpCard.toggleExpanded();
                    }
                    else if (!this._topDPPinned && this.$.dropPointList.scrollTop >= 10) {
                        dpCard.classList.add('pinned');
                        this._topDPPinned = true;
                        this._topDPWasExpanded = dpCard.expanded;
                        if (this._topDPWasExpanded)
                            dpCard.toggleExpanded();
                    }
                }
                else if (this._topDPPinned) {
                    var dpCard = this.$.dropPointList.firstElementChild;
                    dpCard.classList.remove('pinned');
                    this._topDPPinned = false;
                    if (dpCard.expanded)
                        dpCard.toggleExpanded();
                }
            },

            _makeRequest: function (method, url, callback) {
                if (!callback || typeof (callback) !== "function") {
                    throw "No callback";
                }

                if (this.accessToken === "") {
                    var error =  "No access token";
                    this.$.errorNotification = error;
                    this.$.errorNotification.show();
                    callback(error);
                }
                else {
                    var httpRequest = new XMLHttpRequest();
                    this._showAsLoading(true);

                    httpRequest.open(method, url, true);
                    this._attachHeaders(httpRequest, method);

                    httpRequest.onreadystatechange = (function () {
                        if (httpRequest.readyState !== XMLHttpRequest.DONE) {
                            this._showAsLoading(true);
                        }
                        else {
                            this._showAsLoading(false);
                            try {
                                /*var throwErr = Math.floor(Math.random() * (5 - 1 + 1) + 1);
                                if (throwErr === 2) {
                                    this.fire('gfs-token-expired');
                                }
                                else */ if (httpRequest.status == 200 || httpRequest.status == 201) {
                                    callback(null, httpRequest.responseText);
                                }
                                else if (httpRequest.status == 401) {
                                    this.fire('gfs-token-expired');
                                    console.error(httpRequest.responseText);
                                }
                                else {
                                    this.fire('noservice');
                                    console.error(httpRequest.responseText);
                                }                                 
                            }
                            catch (e) {
                                console.error(e.stack);
                                callback(e);
                            }
                        }
                    }).bind(this);                   
                }
                return httpRequest;

            },

            _attachHeaders: function(httpReq, method) {
                var headers = this._computeHeader();
                for (var key in headers) {
                    httpReq.setRequestHeader(key, headers[key]);
                }
                httpReq.setRequestHeader('Content-Type', 'application/json');                
            },

            _computeHeader: function () {
                return {
                    "Authorization": "Bearer " + atob(this.accessToken)
                };
            },

            _postReq: function (mapCenter, data, callback) {
                if (typeof (callback) !== "function") {
                    throw "No callback provided";
                }
                var request = this._makeRequest('POST', "///"+this.apiHost+"/api/CheckoutSession",
                    ///rest-checkout.justshoutgfs.com/api/CheckoutSession/
                    (function (err, data) {
                        if (err) {
                            this.fire('noservice');
                            callback(err);
                        }
                        else {
                            if (!data) {
                                debugger;
                            }
                            this._getReq(mapCenter, data, (function (err) {
                                callback(err);
                            }).bind(this));
                        }
                    }).bind(this)
                );
                request.send(JSON.stringify(data));
            },

            _getReq: function (mapCenter, resourceUrl, callback) {
                var self = this;
                if (typeof (callback) !== "function") {
                    throw "No callback provided";
                }
                this._sessionId = resourceUrl.substring(resourceUrl.lastIndexOf("/") + 1).replace('"','');
                var url = "///"+this.apiHost+"/api/CheckoutSession/" + this._sessionId;
                var request = this._makeRequest('GET', url, (function (err, data) {

                    console.log("GFS Checkout GET response", new Date().getTime());

                    if (err) {
                        this.fire('noservice');
                        callback(err);
                    }
                    else {
                        var result = JSON.parse(data);
                        if (result.message) {
                            callback(result.message);
                        }
                        else {
                            this.set('_data', JSON.parse(data));
                            this.set('_dropPoints', this._data.droppoints);
                            if (this._data.droppoints && this._data.droppoints.length > 0) {
                                //if (!this._dropPoints) {
                                /*}
                                else {
                                    var newDPs = this._data.droppoints.sort(this.sortByDistance);
                                    this._dropPoints = this._dropPoints.concat(newDPs);
                                }*/
                                /* record the region queried e.g.
                                "droppointSettings": {
                                    "maxRadiusMeters": 5000,
                                    "maxResults": 100,
                                    "useDroppointDays": false   // use droppointDays property instead of collectionSlots?
                                },*/
                                // this.$.regionManager.recordQuery(this.droppointSettings, mapCenter, this._data.droppoints);
                                this._processAllDroppoints();
                            }
                            this._processRateData();
                            if (this.useDropPoints && !this._map) 
                                this._makeMap();
                            callback();
                        }

                    }
                }).bind(this));
                request.send("");
            },

            _closeReq: function (callback) {

                // temp hack to get around close session inconsistency
                //if (this.selectedServiceDetails.collectionPoint) {
                //    callback(null, "DPD"); // hard code the carrier to DPD for now
                //    return;
                //}

                var data = {
                    closeSession: true,
                    selectedDeliveryOptionId: this.selectedServiceDetails.serviceCode,
                    selectedDroppointId: this.selectedServiceDetails.collectionPoint || null
                };
              
                var request = this._makeRequest('PATCH', '///'+this.apiHost+'/api/CheckoutSession?sessionId=' + this._sessionId, (function (err, data) {

                    if (err) {
                        callback(err);
                    }
                    else {
                        var result = JSON.parse(data);
                        if (result.selectedService && result.selectedService.carrierName) {
                            callback(null, result.selectedService.carrierName);
                        }
                        else {
                            callback(null);
                        }
                    }
                }).bind(this));
                request.send(JSON.stringify(data));
            },

            /*_requestDroppointsByGeoBoxes: function (boxes, callback) {
                console.log('Request geo boxes');
                var self = this;
                var url = "///"+this.apiHost+"/api/CheckoutSession?sessionId=" + this._sessionId + "&regions=" + JSON.stringify(boxes);
                var request = this._makeRequest('GET', url, (function (err, data) {

                    var result = data?(JSON.parse(data)):{};
                    if (err || result.message) {
                        callback(err || result.message)
                    }
                    else {
                        if (result.droppoints && result.droppoints.length) {
                            this.set('_dropPoints', result.droppoints.sort(this.sortByDistance));
                            this._processAllDroppoints();
                            
                            this._loadDroppointMarkers(this._dropPoints);
                        }
                        callback(null);                     
                    }

                }).bind(this));
                request.send("");
            },*/

            setFavDropPoints: function (droppointList) {
                this._favDropPoints = droppointList;
                this._processFavDroppoints();
            },

            setFavAddresses: function (addressList) {
                this.set('_favAddresses', addressList);
            },

            selectFavAddress: function (address) {
                // the user has selected a physical address for delivery so unselect any drop point - called from p4mCheckout
                this._unselectDropPoint();
                //this.currentMapCenter = { 'lat': address.latitude, 'lng': address.longitude };
            },


            requestDropPointsByAddress: function (address, callback) {
                // an address has changed within the context of the drop points
                // here we need to get re-init the session, get the new DPs, 
                // select a default if possible and display the new location and markers
                this.config.id = address.id;
                this.config.countryCode = address.countryCode.code;
                this.config.county = address.county || address.state;
                this.config.town = address.town;
                this.config.postCode = address.postCode;
                this.config.addressLineCollection = address.addressLineCollection;
                this.config.mapCenter = { 'lat': address.lat, 'lng': address.lng };
                var self = this;
                this.queryForNewAddr(function () {
                    self._showDropPointsView();
                    if (callback)
                        callback();
                });

                /*var self = this;
                this._geoCodeAddress(address, function (err, data) {
                    if (!err && data) {
                        var box = [[data.lng - 0.01, data.lat - 0.01], [data.lng + 0.01, data.lat + 0.01]];
                        self._requestDroppointsByGeoBoxes([box], function () {
                            self.setMapHome(address, title);
                            self._panToGeoLocation(address);
                            callback();
                        });
                    }
                    else {
                        console.error("Failed to locate address", err);
                        callback(err || "Failed to locate address");
                    }
                })*/
            },

            droppointSettings: {
                "maxRadiusMeters": 5000,
                "maxResults": 100,
                "useDroppointDays": false   // use droppointDays property instead of collectionSlots?
            },

            init: function (config, selection, finalCallback) {
                var self = this;
                this._suppliedSelection = selection;
                var requiredFields = [
                    'countryCode',
                    'postCode',
                    'town',
                    'addressLineCollection',
                    'contactEmail',
                    'recipientFirstName',
                    'recipientLastName',
                    'recipientTitle',
                    'cartValue',
                    //'addressPreferences',
                    'deliveryPreferences',
                    'favDropPoints',
                    'favAddresses',
                    'defaultAddress'
                ];
                var missingFields = requiredFields.filter(function (f) {
                    return (typeof (config[f]) == "undefined" || (config[f] == null));
                });
                if (missingFields.length) {
                    throw ("Missing fields: " + missingFields.toString());
                }
                else {
                    this.config = config;
                    var reqDeliveryTypes = config.skipDropPoints ? ["dmStandard"] : ["dmDropPoint", "dmStandard"];
                    this.getPostDataFromConfig(config, reqDeliveryTypes);

                    if (selection && selection.address) {
                        var location = this._postData.request.order.transit.recipient.location;
                        location.countryCode = selection.address.countryCode;
                        location.postCode = selection.address.postCode;
                        location.town = selection.address.town || "";
                        location.county = selection.address.county || selection.address.state;
                        location.addressLineCollection = selection.address.addressLineCollection;
                    }

                    //==== Set fav address data
                    this.setFavDropPoints(this.config.favDropPoints);
                    this.setFavAddresses(this.config.favAddresses);

                    // Post, then select address and method - these can be previously chosen if the cart already exists
                    // or will be defaulted based on the consumer's preferences
                    this.postGfsData(config.mapCenter, function (err) {
                        if (err) {
                            self.initialised = false;
                            console.error("postGfsData() returned: ", err);
                            finalCallback(err);
                            return;
                        }
                        self.initialised = true;
                        if (!selection || (selection.dropPointId && !self._droppointById(selection.dropPointId)))
                            selection = self.getDefaultDelivery();
                        else if (!selection.deliveryMethodId && !selection.deliveryDate)
                            self.autoSelectDeliveryMethod(selection);
                        if (selection.dropPointId) {
                            // try to select the drop point
                            self._completeDropPointSelection(selection.dropPointId, selection.deliveryMethodId, finalCallback);
                        }
                        else {
                            // try to select the physical address delivery method (e.g. std, international, day def, etc)
                            var res = self.setDeliveryMethod(selection.deliveryMethodId, selection.deliveryDate);
                            if (!res) {
                                // this will only fail if a service was pre-selected on an existing cart and no longer exists
                                // or the consumer changes the delivery address manually
                                selection = self.getDefaultDelivery();
                                res = self.setDeliveryMethod(selection.deliveryMethodId, selection.deliveryDate);
                            }
                            if (res)
                                finalCallback();
                            else
                                finalCallback("Could not select a delivery method");
                        }
                    });
                }
            },

            queryForNewAddr: function (finalCallback) {
                // this is only called within the drop points tab, so we need to stay on the tab even if a non-DP address gets selected automatically
                // can be called if the user: selects a fav addr, or a fav DP, or enters an address into the lookup
                var self = this;
                var reqDeliveryTypes = this.config.skipDropPoints ? ["dmStandard"] : ["dmDropPoint", "dmStandard"];
                this.getPostDataFromConfig(this.config, reqDeliveryTypes);
                // Post, then select address and method - these can be previously chosen if the cart already exists
                // or will be defaulted based on the consumer's preferences
                this.initialised = false;
                this.postGfsData(this.config.mapCenter, function (err) {
                    if (err) {
                        self.initialised = false;
                        console.error("postGfsData() returned: ", err);
                        finalCallback(err);
                        return;
                    }
                    self.initialised = true;
                    var selection = self.getDefaultDelivery(true);
                    if (selection.dropPointId) {
                        // try to select the drop point - need to force refresh of map
                        self._showingDroppoints = false;
                        self._completeDropPointSelection(selection.dropPointId, selection.deliveryMethodId, finalCallback);
                    }
                    else {
                        // try to select the physical address delivery method (e.g. std, international, day def, etc)
                        var res = self.setDeliveryMethod(selection.deliveryMethodId, selection.deliveryDate);
                        if (!res) {
                            // this will only fail if a service was pre-selected on an existing cart and no longer exists
                            // or the consumer changes the delivery address manually
                            selection = self.getDefaultDelivery(true);
                            res = self.setDeliveryMethod(selection.deliveryMethodId, selection.deliveryDate);
                        }
                        if (res)
                            finalCallback();
                        else
                            finalCallback("Could not select a delivery method");
                    }
                });
            },

            initCartTotalOnly: function (config, finalCallback) {
                var self = this;
                //==== Create post data
                this.getPostDataFromConfig(config, ["dmDropPoint", "dmStandard"]);
                // Post, then select address and method - these can be previously chosen if the cart already exists
                // or will be defaulted based on the consumer's preferences
                this.postGfsData(config.mapCenter, function (err) {
                    if (err) {
                        self.initialised = false;
                        console.error("postGfsData() returned: ", err);
                        finalCallback(err);
                        return;
                    }
                    self.initialised = true;
                    finalCallback();
                });
            },

            getPostDataFromConfig: function (config, reqDeliveryTypes) {
                //==== Create post data
                var now = new Date();
                var maxDate = new Date(now.getTime() + (1000 * 60 * 60 * 24 * 14));
                this._postData = {
                    "request":
                    {
                        "dateRange": {
                            "dateFrom": this._makeDateStr(now),
                            "dateTo": this._makeDateStr(maxDate)
                        },
                        droppointSettings: this.droppointSettings,
                        "order": {
                            "transit": {
                                "recipient": {
                                    "location": {
                                        "countryCode": {
                                            "code": config.countryCode,
                                            "encoding": "ccISO_3166_1_Alpha2"
                                        },
                                        "postCode": config.postCode,
                                        "town": config.town,
                                        "county": config.county,
                                        "addressLineCollection": config.addressLineCollection
                                    },
                                    "contactDetails": {
                                        "email": config.contactEmail
                                    },
                                    "person": {
                                        "firstName": config.recipientFirstName,
                                        "lastName": config.recipientLastName,
                                        "title": config.recipientTitle || "Mr"
                                    }
                                }
                            },
                            "value": {
                                "currencyCode": "GBP",
                                "value": config.cartValue
                            }
                        },
                        "requestedDeliveryTypes": reqDeliveryTypes,
                        "session": { "sessionID": this._sessionId ? this._sessionId : "" }
                    }
                };
            },

            //Select a delivery address based on the users preferences
            getDefaultDelivery: function (stayOnTab) {
                // select a default address or droppoint during initial load, or if loading
                // an existing cart and the address / DP is no longer available

                // first use the preferred delivery address to initialise GFS and return local DPs
                // if the consumer then prefers to use their own DPs see if one is in the list
                // or if the consumer prefers to use the nearest DP then select that from the list
                var defaultPrefs = ["useMyDeliveryAddress", "useMyDropPoints", "useRetailerDropPoint"];
                var prefs = this.config.addressPreferences;
                if (!prefs || prefs.constructor !== Array) 
                    prefs = defaultPrefs;
                var dropPointId = null, delDate = null;
                var serviceId;
                if (prefs[0] !== 'useMyDeliveryAddress') {
                    // consumer wants to use a DP by preference - either their preferred or the closest
                    var dp;
                    if (prefs[0] === 'useMyDropPoints' && this.config.favDropPoints && this.config.favDropPoints.length > 0)
                        // they want to use one of their preferred DPs if possible
                        for (var i = 0; i < this.config.favDropPoints.length; i++) {
                            dp = this._droppointById(this.config.favDropPoints[i].droppointId);
                            if (dp)
                                break;
                        }
                    if (!dp) {
                        // a preferred DP is not being used, so check for next preference
                        if (prefs[0] === 'useMyDropPoints' && prefs[1] === 'useMyDeliveryAddress')
                            // delivery address is second pref
                            return this.getDefaultServiceId(stayOnTab);
                        // closest retailer DP is first or second pref
                        if (this._dropPoints && this._dropPoints.length > 0)
                            dp = this._dropPoints[0];
                    }
                    if (dp) {
                        dropPointId = dp.droppointId;
                        serviceId = dp.deliveries[0].service.id;
                        return {
                            dropPointId: dropPointId,
                            deliveryMethodId: serviceId,
                            address: this._getCurrentDeliveryAddress()
                        };
                    }
                }
                // consumer prefers their own address or no DP could be used
                return this.getDefaultServiceId(stayOnTab);
            },

            getDefaultServiceId: function (stayOnTab) {
                // Choose the most preferred standard delivery
                var serviceId, delDate;
                if (this.standardRates.length) {
                    serviceId = this.standardRates[0].id;
                    if (this.config.deliveryPreferences) {
                        var sortFunction = this._getDeliveryMethodSortFunction();
                        if (this.config.deliveryPreferences.preferSoonest && this._data.dayDefinite && this._data.dayDefinite.length > 0) {
                            this._data.dayDefinite[0].rates.sort(sortFunction);
                            serviceId = this._data.dayDefinite[0].rates[0].id;
                            delDate = this._data.dayDefinite[0].deliveryDate;
                            if (!stayOnTab)
                                this.showPage_Calendar();
                        }
                        else {
                            this.standardRates.sort(sortFunction);
                            serviceId = this.standardRates[0].id;
                            if (!stayOnTab)
                                this.showPage_Standard();
                        }
                    }
                }
                return {
                    deliveryMethodId: serviceId,
                    deliveryDate: delDate,
                    address: this._getCurrentDeliveryAddress()
                }
            },

            //Assuming an address has been chosen, choose a delivery method that best suits the user's preferences:
            //preferSoonest: true/false
            autoSelectDeliveryMethod: function (selection) {
                if (this.standardRates.length) {
                    if (this.config.deliveryPreferences && this.config.deliveryPreferences.preferSoonest) {
                        var sortFunction = this._getDeliveryMethodSortFunction();
                        this._data.dayDefinite[0].rates.sort(sortFunction);
                        selection.deliveryMethodId = this._data.dayDefinite[0].rates[0].id;
                        selection.deliveryDate = this._data.dayDefinite[0].deliveryDate;
                        this.showPage_Calendar();
                    }
                    else {
                        selection.deliveryMethodId = this.standardRates[0].id;
                        this.showPage_Standard();
                    }
                }
            },

            /*            runDeliveryAddressPreferences: function(prefs, defaultAddress, finalCallback) {

                //Select address based on preferences
                var defaultPrefs = ["useMyDeliveryAddress", "useMyDropPoints", "useRetailerDropPoint"];
                if (!prefs || prefs.constructor !== Array) {
                    console.log("runDeliveryAddressPreferences: using default", defaultPrefs);
                    prefs = defaultPrefs;
                }

                //Preferred address
                //Process a priority list of address preferences
                var self = this;
                var handlers = {
                    "useMyDeliveryAddress": function (callback) { self.setGfsAddress(defaultAddress, true, callback); },
                    "useMyDropPoints": function (callback) { self.selectNearestFavDropPoint(callback); },
                    "useRetailerDropPoint": function (callback) { self.selectNearestDropPoint(callback); }
                };
                var handlerArray = [];
                prefs.forEach(function (pref) {
                    handlerArray.push(handlers[pref]);
                });

                function runHandler(index) {
                    handler = handlerArray[index || 0];
                    if (handler) {
                        //console.log("Running handler", index);
                        handler(function (err, data) {
                            //console.log("Handler returned", err);
                            if (err) {
                                runHandler(index + 1);
                            }
                            else {
                                finalCallback();
                            }
                        });
                    }
                    else {
                        finalCallback();
                        //console.log("Finished running handlers");
                    }
                }

                runHandler(0);

            },*/

            //Select a delivery service
            //TODO: Refactor?
            setDeliveryMethod: function (methodId, dateOverride) {

                if (!methodId) {
                    return;
                }

                var newMethod = this._getDeliveryRateById(methodId);
                if (!newMethod) {
                    console.error("Method not available");
                    return;
                }

                else {
                    //The original service object is attached directly to selectedServiceDetails, allowing us to deselect it directly
                    if (this.selectedServiceDetails && this.selectedServiceDetails._originalMethodObject) {
                        this.selectedServiceDetails._originalMethodObject.selected = false;
                    }

                    newMethod.selected = true;

                    var newSelectedServiceDetails = {
                        _originalMethodObject: newMethod,
                        serviceId: methodId,
                        service: newMethod.methodTitle,
                        serviceCode: newMethod.deliveryOptionId,
                        carrier: newMethod.carrierName,
                        shipping: newMethod.price,
                        currencySymbol: this.currencySymbol
                    }

                    if (dateOverride) {
                        newSelectedServiceDetails.expDeliveryDate = moment.utc(dateOverride).toISOString();
                        this.$.calendar.selectShippingOption(methodId, dateOverride, true);
                    }
                    else {
                        this.$.calendar.selectShippingOption(null, null, true);
                        newSelectedServiceDetails.expDeliveryDate = moment.utc(newMethod.deliveryTimeTo).add(newMethod.maxDD - newMethod.minDD, 'days').toISOString();
                    }

                    if (newMethod.serviceType.type == "dmStandardDropPoint" && this._selectedDropPoint)
                    {
                        newSelectedServiceDetails.collectionPoint = this._selectedDropPoint.droppointId;
                        newSelectedServiceDetails.companyName = this._selectedDropPoint.droppointDescription;
                        newSelectedServiceDetails.providerId = this._selectedDropPoint.providerId;
                        newSelectedServiceDetails.provider = this._selectedDropPoint.providerName;
                        newSelectedServiceDetails.deliveryAddress = this._selectedDropPoint.geoLocation;
                        this.set('_selectedDropPoint.deliveryMethod', methodId);
                    }
                    else {

                        //If we have selected something other than a droppoint, and we previously had a droppoint selected,
                        //We need to unselected it and then auto-select a standard address
                        if (this._selectedDropPoint) {
                            this._unselectDropPoint(); //If unselect a droppoint, default back to a fav address
                        }
                        else {
                            //We had a standard address selected already, apparently. 
                            //So we don't need to autoselect one.
                            console.log("Not selecting a standard address automatically.")
                        }
                        newSelectedServiceDetails.deliveryAddress = this._getCurrentDeliveryAddress();
                    }
                    this.set('selectedServiceDetails', newSelectedServiceDetails);                  

                    this.set('standardRates', this._getStandardServices());

                    this.$.standardRatesTemplate.render();
                    this.fire('selectedservicechanged', this.selectedServiceDetails);
                    this._updateUi();
                    return this.selectedServiceDetails;
                }
            },

            _getCurrentDeliveryAddress: function() {
                if (this.config.id) {
                    var addr = this._favAddrById(this.config.id);
                    if (addr)
                        return addr;
                }
                return this.config.defaultAddress;
            },
            
            //Index and tidy GFS rate data
            _processRateData: function () {
                if (this._data.nonDayDefinite.constructor === Array && this._data.nonDayDefinite.length > 0) {
                    this._data.standardRates = this._getStandardServices();
                    this.set('standardRates', this._data.standardRates);
                    //console.log(this.standardRates);
                }
                //this.notifyPath('_data.dayDefinite'); //??? Needed?
            },

            _showAsLoading: function (loading) {

                if (loading) {
                    this.$$('#list-spinner').active = "true";
                    this.$$('#standard-spinner').active = "true";
                    this.$$('#list-loading').classList.remove('hidden');
                    this.$$('#standard-loading').classList.remove('hidden');
                    this.$$('#calendar-loading').classList.remove('hidden');
                }
                else {
                    this.$$('#list-spinner').active = null;
                    this.$$('#standard-spinner').active = null;
                    this.$$('#list-loading').classList.add('hidden');
                    this.$$('#standard-loading').classList.add('hidden');
                    this.$$('#calendar-loading').classList.add('hidden');
                }
            },
            
            sortDropPoints: function (a, b) {
                var aOrd = this.getDPOrder(a);
                var bOrd = this.getDPOrder(b);
                if (aOrd < bOrd) return -1;
                else if (aOrd > bOrd) return 1;
                else return 0;
            },

            getDPOrder: function (dp) {
                return dp.selected ? -1 : (dp.preferred ? dp.distanceInMeters : 10000 + dp.distanceInMeters);
            },

            /*sortByDistance: function (a, b) {
                if (a.selected) return -1
                else if (b.selected) return 1
                else if (a === b) return 0;
                else return a.distanceInMeters < b.distanceInMeters ? -1 : 1;
            },*/

            /*filterToMap: function (item) {
                if (this._map) {
                    if (this._mapViewPort) {
                        var sw = { longitude: this._mapViewPort[0][0], latitude: this._mapViewPort[0][1] };
                        var ne = { longitude: this._mapViewPort[1][0], latitude: this._mapViewPort[1][1] };

                        if ((item.geoLocation.coordinates.latitude > sw.latitude && item.geoLocation.coordinates.latitude < ne.latitude)
                            && (item.geoLocation.coordinates.longitude > sw.longitude && item.geoLocation.coordinates.longitude < ne.longitude)) {
                            return true;
                        }
                        else {
                            return false;
                        }                      
                    }
                    else return true;
                }
                else {
                    return true;
                }              
            },*/
            /*
            getClosestDroppoint: function (dpList) {
                return dpList.reduce(function (prev, curr) {
                    return (prev.distanceMeters < curr.distanceInMeters) ? prev : curr;
                });
            },*/

            _getDeliveryMethodSortFunction: function() {

                if (this.config.deliveryPreferences.preferSoonest) {
                    return (
                        function(a, b) {
                            if (a && b && a.deliveryTimeTo && b.deliveryTimeTo) {
                                return a.deliveryTimeTo <= b.deliveryTimeTo ? -1 : 1;
                            }
                            else {
                                console.warn("Sorting by deliveryDate: invalid parameter: ", a, b);
                                return 1;
                            }
                            
                        }
                    );
                }
                else {
                    return (
                        function(a, b) {

                            if (a && b) {
                                if (a.service && b.service) {
                                    aPrice = a.service.price;
                                    bPrice = a.service.price;
                                }
                                else {
                                    aPrice = a.price;
                                    bPrice = b.price;
                                }  
                                return aPrice > bPrice? 1 : -1;
                                                            
                            }
                            else {
                                console.warn("Sorting by price: invalid parameter: ", a, b);
                                return 1;
                            }
                           
                        }
                    );
                }
            },
            
            _processAllDroppoints: function () {
                this._indexDropPointProviders(this._data.dayDefinite);
                this._indexDropPointProviders(this._data.nonDayDefinite);
                //this._removeDupDropPoints();
                this._addDropPointDeliveries();
                this._sortDropPointServices();
                this._processFavDroppoints();
            },

            /*
            _removeDupDropPoints: function () {
                var self = this;
                var uniques = [];
                for (var j = 0; j < this._dropPoints.length; j++) {
                    var dp = this._dropPoints[j];
                    if (!uniques.find(function(item) {
                        return item.droppointId == dp.droppointId;
                    })) {
                        uniques.push(dp);
                    }
                }
                this.set('_dropPoints', uniques);
            }, */

            _sortDropPointServices: function() {
                if (this.config.deliveryPreferences) {
                    var sortFunction = this._getDeliveryMethodSortFunction();
                    this._dropPoints.map(
                        function (item) {
                            item.preferred = false;
                            if (item.deliveries && item.deliveries.length) {
                                item.deliveries = item.deliveries.sort(sortFunction);
                            }                           
                        });
                    
                }
            },

            _addDropPointDeliveries: function () {
                var self = this;
                this._dropPoints.map(
                    function (item) {

                        item.collectionPoint = true;
                        item.deliveries = self._findDropPointDeliveries(item.providerId);
                        return item;
                    }
                );
            },

            _processFavDroppoints: function()
            {
                //Now replace preferred items with real data
                var self = this;
                this._favDropPoints = this._favDropPoints.map(function (item) {
                    var existingItem = self._droppointById(item.droppointId);
                    if (existingItem) {
                        existingItem.selected = item.selected;
                        existingItem.preferred = true;
                        existingItem.prefOrder = item.prefOrder;
                    }
                    return existingItem || item;
                });//.sort(this.sortByDistance);
            },
            
            _makeMap: function () {
                var self = this;

                var home = null;
                var imgSrc = this.resolveUrl('images/gmap-icon-selected-shadow-32px.png');
                var imgTag = '<img src="' + imgSrc + '">';// style="position:relative;top:40px;left:12px;">';
                //var selectDPPanel = this.$.infobox_droppoint;
                self._infoWindow = new google.maps.InfoWindow({
                    //TIP: To use dynamic content here, use "droppoint_info" as shown in comment below. Then place a droppoint widget or similar into the droppoint_info element.
                    //content: this.$.infobox_droppoint
                    content: imgTag
                });

                /* The infoWindow is the place marker attached to the currently selected drop point
                 * The google.maps.event.addListener() event waits for
                 * the creation of the infowindow HTML structure 'domready'
                 * and before the opening of the infowindow defined styles
                 * are applied.
                 */
                google.maps.event.addListener(self._infoWindow, 'domready', function () {
                    // this code is to display just an image with no other elements
                    var iwOuter = document.getElementsByClassName('gm-style-iw')[0];
                    if (iwOuter) {
                        iwOuter.style.overflow = 'visible';
                        iwOuter.style.top = '46px';
                        iwOuter.style.left = '26px';
                        //// the white bkg and shadow are grouped in the prev element
                        iwOuter.previousSibling.style.display = 'none';
                        //// reduce the size of the non-clickable area created by the info window
                        iwOuter.parentElement.style.width = 0;
                        //// remove the scroll bars from the img parent divs
                        iwOuter.firstChild.style.overflow = 'visible';
                        iwOuter.firstChild.firstChild.style.overflow = 'visible';
                        //// hide the close button
                        iwOuter.nextSibling.style.display = 'none';
                    } 
                });

                var position = new google.maps.LatLng(37, 0);

                // map options
                var mapOptions = {

                    // initial zoom level
                    zoom: self.startingZoomLevel,
                    minZoom: self.startingZoomLevel - 2,

                    // initial center position
                    center: position,

                    // type of map (ROADMAP, SATELLITE, TERRAIN, HYBRID)
                    mapTypeId: google.maps.MapTypeId.TERRAIN,

                    // show or hide streetview control
                    streetViewControl: false,
                    fullscreenControl: false,

                    // show or hide the google map UI
                    disableDefaultUI: self.hideMapUI,

                    // map controls (only if disableDefaultUI is false)
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
                        position: google.maps.ControlPosition.TOP_RIGHT,
                    },

                    zoomControlOptions: {
                        style: google.maps.ZoomControlStyle.SMALL,
                        position: google.maps.ControlPosition.TOP_RIGHT
                    },

                    // remove points of interest from the map so as not to interfere
                    styles: [{
                        "featureType": "poi",
                        "elementType": "labels",
                        "stylers": [{
                            "visibility": "off"
                        }]
                    }]
                };

                //var postcode = document.getElementById('shipping:postcode').value; //Improve selection method

                self._map = new google.maps.Map(self.$.gfsMapCanvas, mapOptions);
                window.map = self._map;            

                // 'idle' event is triggered when the user stopped zooming/dragging;
                //google.maps.event.addListener(self._map, 'idle', function (event) {
                //    self._mapMoved();
                //});

                // 'bounds_changed' event is triggered when the user stopped zooming;
                //google.maps.event.addListener(self._map, 'bounds_changed', function (event) {
                //    if (self._currentMarker) {
                //        var reShowMarker = map.getBounds().contains(self._currentMarker.getPosition());
                //        if (reShowMarker)
                //            self._infoWindow.open(self._map, self._currentMarker);
                //    }
                //});

                //google.maps.event.addListener(self._map, 'click', function (event) {
                    //console.log('MAP EVENT click');
                    //self._unselectDropPoint();
                //});

                //google.maps.event.addListener(self._map, 'center_changed', function (event) {
                    //console.log('MAP EVENT center_changed');
                    //self._unselectDropPoint();
                //});

            },

            _loadDroppointMarkers: function (dropPointsArray) {
                var self = this;
                if (!dropPointsArray) return;
                //=== Drop point markers
                var marker;
                dropPointsArray.forEach(
					function (pointItem) {
					    if (true || !pointItem.marker) {
					        var getCountryCode = pointItem.geoLocation.countryCode;
					        var markerConfig = {
					            position: new google.maps.LatLng(pointItem.geoLocation.coordinates.latitude, pointItem.geoLocation.coordinates.longitude),
					            map: self._map,
					            //animation: google.maps.Animation.DROP,
					            //title: pointItem.droppointDescription,
					            customData: pointItem,
					            icon: self._droppointIcon(getCountryCode) + '/' + pointItem.providerName.toLowerCase() + '.png',
					            zIndex: google.maps.Marker.MAX_ZINDEX
					        };
					        //console.log(pointItem.geoLocation.coordinates.longitude, pointItem.geoLocation.coordinates.latitude);
					        marker = new google.maps.Marker(markerConfig);
					        marker.addListener('click', function (clickedMarker) {
					            self._selectDropPointMarker(this);
					        });
					        //marker.addListener('mouseover', function (inspectedMarker) {
					        //    var latlng = this.getPosition();
					        //    self._inspectDropPointMarker(this);
					        //});
					        //marker.addListener('mouseout', function () {
					        //    self._hideDropPointInspector();
					        //});
					        // add a link to the marker to get to it from the droppoint, need to animate and centre the marker if selecting from list view
					        pointItem.marker = marker;
					    }
					}
				);
            },

            _droppointIcon: function(countryCode) {
                var url = this.resolveUrl('./images/');
                if (!countryCode) {
                    return url;
                }
                else {                
                    switch (countryCode) {
                    case "DE":
                        return url + 'de';
                    case "FR":
                    case "BE":
                    case "ES":
                        return url + 'fr';
                    default:
                        return url + 'gb';
                    }
                }
            },

            _geoCodeAddress: function (address, callback) {
                if (address.lat && address.lng) {
                    callback(null, { 'lat': address.lat, 'lng': address.lng });
                    return;
                }
                if (!address.addressLineCollection || address.addressLineCollection.length == 0) {
                    callback("No results");
                    return;
                }
                var addressStr = address.addressLineCollection[0] + "," + address.postCode;
                var geocoder = new google.maps.Geocoder();
                geocoder.geocode({
                    componentRestrictions: {
                        country: address.countryCode.code || this.countryCode
                    },
                    address: addressStr
                },
                function (results, status) {
                    if (status == google.maps.GeocoderStatus.OK) {
                        if (results && results.length) {
                            var geoLocation = results[0].geometry.location;
                            callback(null, { 'lat': geoLocation.lat(), 'lng': geoLocation.lng() });
                        }
                    }
                    else {
                        callback("No results");
                    }
                });
            },
            
            _geoCodePosition: function (position, callback) {
                var geocoder = new google.maps.Geocoder();
                geocoder.geocode({ location: position },
                    function (results, status) {
                        if (status == google.maps.GeocoderStatus.OK && results && results.length) 
                            callback(null, results[0]);
                        else 
                            callback("No results");
                    });
            },

            //_mapMoved: function () {
            //    var self = this;
            //    if (self._moveMapTimeout) {
            //        window.clearTimeout(self._moveMapTimeout);
            //    }
            //    self._moveMapTimeout = window.setTimeout((function() {
            //        self._reloadDroppoints();
            //    }).bind(this), 100);

            //},

            // used for trouble shooting
            _drawBoxes: function(boxes, color) {
                var self = this;
                boxes.forEach(function(rect) {
                    var boxCoords = [{
                        lat: rect[0][1],
                        lng: rect[0][0]
                    }, // north west
                        {
                            lat: rect[0][1],
                            lng: rect[1][0]
                        }, // south west
                        {
                            lat: rect[1][1],
                            lng: rect[1][0]
                        }, // south east
                        {
                            lat: rect[1][1],
                            lng: rect[0][0]
                        } // north east
                    ]

                    self._map.data.setStyle({
                        fillColor: color,
                        strokeColor: color,
                        strokeWeight: 2
                    });
                    self._map.data.add({
                        geometry: new google.maps.Data.Polygon([boxCoords])
                    });
                });
            },

            _updateMapViewPort: function() {
                var bounds = this._map.getBounds();
                if (!bounds) {
                    console.error("Failed to get map bounds");
                    return;
                }          
                var northEast = [bounds.getNorthEast().lng(), bounds.getNorthEast().lat()];
                var southWest = [bounds.getSouthWest().lng(), bounds.getSouthWest().lat()];
                if (northEast[0] === southWest[0] && northEast[1] === southWest[1]) return;
                this._mapViewPort = [southWest, northEast];
            },

            _updateUi: function() {
            },

            
            /*_reloadDroppoints: function () {
                return; // not used for now
                if (this._sessionId) {
                    console.log('reloadDroppoints()');

                    //Get viewport rectangle
                    this._updateMapViewPort();
                    if (!this._mapViewPort) return;

                    var boxes = [];
                    
                    this.$.regionManager.getUncoveredRectangles(this._mapViewPort).forEach(function (rect) {
                        console.log('area: ', rect.areaM());
                        boxes.push(rect.toGeoBox());
                    });

                    //console.log('Boxes to request:', JSON.stringify(boxes));
                    this._drawBoxes(boxes, 'green');
                    
                    if (boxes.length > 0 && this._mapViewPort) {
                        this._requestDroppointsByGeoBoxes(boxes, function () { });
                    }
                    else {
                        console.log("Not requesting any regions");
                    }
                    var self = this;
                    this._resetMap(this._map, function () {  });
                }
            },*/

            _favDPsProcessed: true, // we're skipping querying for these now
            /*_requestDroppointList: function (droppointList, callback) {
                if (true || droppointList.length === 0) {
                    callback();
                }
                else {
                    var self = this;

                    //Make array of geoBoxes, tightly encompassing each droppoint
                    var boxes = [];
                    droppointList.forEach(function (dp) {
                        boxes.push([[dp.geoLocation.coordinates.longitude - 0.000001, dp.geoLocation.coordinates.latitude - 0.000001], [dp.geoLocation.coordinates.longitude + 0.000001, dp.geoLocation.coordinates.latitude + 0.000001]]);
                    });
                    this._requestDroppointsByGeoBoxes(boxes, function () {
                        self._favDPsProcessed = true;
                        callback();
                    });
                }

            },*/

            //_showDropPointDetails: function() {
            //    this.mapHeight = this.$.gfsMapCanvas.clientHeight;
            //    this._dropPointDetailsClass = "fade-in";
            //},

            _showDropPointsView: function () {
                var self = this;
                //this.fire('show-droppoints');
                if (this._showingDroppointsMap) {
                    this._loadDroppointMarkers(this._dropPoints);                                                                           
                    this._resetMap(this._map, function() {
                        self._openSelectedDropPointInfoWindow();
                        if (!self._currentMarker)
                            self.panToDefaultLocation();
                    });
                }
            },

            checkMapIsReset: function (force) {
                if (this._map && (force || !this.mapIsReset)) {
                    var self = this;
                    this._resetMap(this._map, function () {
                        self.panToDefaultLocation();
                        if (self._currentMarker)
                            self._infoWindow.open(self._map, self._currentMarker);
                        self.mapIsReset = true;
                    });
                }
            },

            _resetMap: function (map, callback) {
                var self = this;
                if (map) {
                    window.setTimeout(function () {
                        google.maps.event.trigger(map, 'resize');
                        self.mapHeight = self.$.gfsMapCanvas.clientHeight;
                        if (callback) callback();
                    }, 100);
                }           
            },

            _getHomeIcon: function() {
                if (this.homeIcon) {
                    return this.homeIcon;
                } else {
                    return this.resolveUrl('./images/home.png');
                }
            },

            _openSelectedDropPointInfoWindow: function () {
                if (this._showingDroppointsMap && this._selectedDropPoint) {
                    var dp = this._droppointById(this._selectedDropPoint.droppointId);
                    
                    if (dp) {
                        if (this._currentMarker == dp.marker) return;
                        else {
                            this._currentMarker = dp.marker;
                            this._currentMarker.zIndex = google.maps.Marker.MAX_ZINDEX + 1;
                        }
                    }
                   
                    this.$.dropPointRadio.setAttribute('checked', 'true');
                    if (!this._infoWindow.attachedTo || this._infoWindow.attachedTo !== this._currentMarker.customData.droppointId) {
                        this._infoWindow.open(this._map, this._currentMarker);
                        this._infoWindow.attachedTo = this._currentMarker.customData.droppointId;
                    }
                    this._map.panTo(this._currentMarker.getPosition());
                }
            },

            _onLocateDroppointEvent: function (e) {
                // the user has clicked on the selected drop point panel so we will pan it to the center of the map
                this.panToDefaultLocation();
            },

            //=== Received event from droppoint widget, indicating that a delivery method from a droppoint has been chosen
            //Note that this doesn't fire just when a droppoint is clicked on, or when selected is set to true;
            //To fire, it must be selected AND a delivery method chosen.
            //
            //Make this droppoint the 'selected' one, and open the info window
            _onDropPointSelectedEvent: function (e) {
                if (!e.detail.deliveryMethod) {
                    console.log("No delivery method chosen.");
                }

                //.if (this._selectedDropPoint && this._selectedDropPoint.droppointId == e.detail.droppointId) return; //Already selected
                //If there is no method, _completeDropPointSelection will choose one for us
                var self = this;
                self.fire('dp-selected-map', e.detail.droppointId);
                //Get selected delivery method
                this._completeDropPointSelection(e.detail.droppointId, e.detail.deliveryMethod, function () {
                    self._redisplayDropPointList();
                    self.panToDefaultLocation();
                });

            },

            _redisplayDropPointList: function () {
                // if there is no longer a DP selected then we need to make sure the first item is not pinned
                if (!this._selectedDropPoint) {
                    var dpCard = this.$.dropPointList.firstElementChild;
                    if (this._topDPPinned) {
                        dpCard.classList.remove('pinned');
                        this._topDPPinned = false;
                        if (this._topDPWasExpanded)
                            dpCard.toggleExpanded();
                    }
                }
                this.$.dropPointListTemplate.render();
            },

            //==== Make this droppoint the 'selected' one
            //If no method chosen, auto-choose one
            _completeDropPointSelection: function(droppointId, methodId, callback) {
                if (!callback) { callback = function () { }; }
                this.showPage_Droppoints();
                var self = this;
                if (methodId && (methodId == this.selectedServiceDetails.serviceId && this.selectedServiceDetails.collectionPoint == droppointId) ) {
                    callback(null); 
                } 
                else {
                    var dp = this._droppointById(droppointId)            
                    this.set("_selectedDropPoint", dp);
                    this.set("_selectedDropPoint.selected", true);
                    if (!methodId) 
                        methodId = dp.deliveries[0].service.id;
                    this.setDeliveryMethod(methodId);    
                    this._openSelectedDropPointInfoWindow();
                    this._updateUi();
                    callback(null);
                }
            },

            _selectDropPoint(dropPointId, callback) {
                var self = this;
                self.fire('dp-selected-map', dropPointId);
                this._completeDropPointSelection(dropPointId, null, function () {
                    self._redisplayDropPointList();
                    if (callback)
                        callback();
                })
            },

            //=== Select a drop point marker
            //Make it the 'selected' one
            //Select the infobox's gfs-droppoint widget.
            _selectDropPointMarker: function (marker) {
                this._selectDropPoint(marker.customData.droppointId);
            },

            /* use this code for mouse over DP info
            _inspectDropPointMarker: function (marker) {
                var dp = this._droppointById(marker.customData.droppointId);
                this._inspectDropPoint(dp, marker);
            },

            _inspectDropPoint: function (dp, marker) {
                this._hideDropPointInspector();

                this._inspectDropPointTimeout = window.setTimeout((function() {
                    this.set('_inspectedDropPoint', dp);
                    this.$.inspectedDropPoint.buildWeekCollection();
                    this._hideDropPointInspector();


                    this._customInfoBox = new InfoBox({
                        latlng: marker.getPosition(),
                        map: this._map,
                        content: this.$.inspectingDropPointPanel
                    });       
                }).bind(this), 350);


            },

            _hideDropPointInspector: function() {
                if (this._inspectDropPointTimeout) {
                    window.clearTimeout(this._inspectDropPointTimeout);
                    delete this._inspectDropPointTimeout;
                }
                if (this._customInfoBox) {
                    this._customInfoBox.remove();

                    this._customInfoBox = null;
                    this.set('_inspectedDropPoint', null);
                }
            }, */

            _selectFavDropPoint: function (e) {
                // has this drop point been queried for?
                var dpId = e.target.droppointData.droppointId;
                var dp = this._droppointById(dpId);
                if (!dp) {
                    // check the fav DPs
                    var self = this;
                    for (var i = 0; i < this._favDropPoints.length; i++) {
                        if (this._favDropPoints[i].droppointId === dpId) {
                            // if we get here it means the user has selected a fav DP that is not in a queried region
                            dp = this._favDropPoints[i];
                            var addr = {
                                countryCode: { code: dp.geoLocation.countryCode },
                                town: dp.geoLocation.town,
                                postCode: dp.geoLocation.postCode,
                                addressLineCollection: dp.geoLocation.addressLineCollection || dp.geoLocation.addressLines,
                                lat: dp.geoLocation.coordinates.latitude,
                                lng: dp.geoLocation.coordinates.longitude
                            };
                            this.requestDropPointsByAddress(addr, function () {
                                self._selectDropPoint(dpId);
                            });
                        }
                    }
                }
                else
                    this._selectDropPoint(dpId);
            },

            _unselectDropPoint: function () {
                if (this._selectedDropPoint) {
                    if (this._infoWindow) {
                        this._infoWindow.attachedTo = null;
                        this._infoWindow.close();
                    }
                    //this._hideDropPointDetails();
                    this._updateUi();
                    this._selectedDropPoint = null;
                    if (this._currentMarker) {
                        this._currentMarker.zIndex = google.maps.Marker.MAX_ZINDEX;
                        this._currentMarker = null;
                    }
                }
                this.fire('dp-selected-map', null);
            },
           
            _favAddrById: function (addrId) {
                if (this._favAddresses) 
                    for (var i = 0; i < this._favAddresses.length; i++)
                        if (this._favAddresses[i].id === addrId)
                            return this._favAddresses[i];
            },

            _droppointById: function (droppointId) {
                if (this._dropPoints)
                    for (var i = 0; i < this._dropPoints.length; i++)
                        if (this._dropPoints[i].droppointId === droppointId)
                            return this._dropPoints[i];
            },

            _locateMe: function(callback) {
                var self = this;
                // Try HTML5 geolocation.
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        function(position) {
                            var pos = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            };
                            self._geoCodePosition(pos, function (err, addr) {
                                self.gotoGoogleAddress(addr);
                            });
                        },
                        function(err) {
                            if (callback) {
                                callback(err, pos);
                            }
                            console.error(JSON.stringify(err));
                        }
                    );
                } 
                else {
                    console.error("Browser does not support geolocation");
                }
            },

            setMapHome: function (location, label) {
                if (!label)
                    label = 'Home';
                var homeMarkerConfig = {
                    position: location,
                    map: this._map,
                    //animation: google.maps.Animation.DROP,
                    title: label,
                    html: label,
                    icon: this._getHomeIcon()
                };
                marker = new google.maps.Marker(homeMarkerConfig);
                this.currentMapCenter = location;
                //this._map.setCenter(homeMarkerConfig.position);
            },

            currentMapCenter: null,
            panToDefaultLocation: function () {
                var self = this;
                if (this._currentMarker) {
                    self._infoWindow.open(self._map, self._currentMarker);
                    self._panToGeoLocation(this._currentMarker.getPosition());
                }
                else if (this.currentMapCenter) {
                    self._panToGeoLocation(this.currentMapCenter);
                }
                else if (this._postData.request.order.transit.recipient.location) {
                    var loc = this._postData.request.order.transit.recipient.location;
                    this._geoCodeAddress(loc, function (err, data) {
                        if (err)
                            console.error('panToDefaultLocation():', err);
                        else {
                            self.setMapHome(data, loc.addressLineCollection[0]);
                            self._panToGeoLocation(data);
                        }
                    });
                }
                else if (this._favAddresses.length) {
                    if (this._favAddresses[0].geoLocation.coordinates.latitude && this._favAddresses[0].geoLocation.coordinates.longitude) {
                        var geoLocation = {
                            lat: this._favAddresses[0].geoLocation.coordinates.latitude,
                            lng: this._favAddresses[0].geoLocation.coordinates.longitude
                        };
                        this.setMapHome(geoLocation, this._favAddresses[0].addressLineCollection[0]);
                        this._panToGeoLocation(geoLocation);
                    }
                }
            },


            _makeDateStr: function(d) {
                function pad(n, padSize) {
                    var str = n.toString();
                    var padZeros = (new Array(padSize)).join('0');
                    return (padZeros + str).substr(-padSize);
                }
                return (
                    pad(d.getFullYear(), 4) + '-' +
                    pad(d.getMonth() + 1, 2) + '-' +
                    pad(d.getDate(d), 2)
                );
            },

            _selectCalendarShippingOption: function (e) {
                //console.log('Updating delivery options with', e.detail.shippingMethodId, e.detail.deliveryDate);
                this.setDeliveryMethod(e.detail.shippingMethodId, e.detail.deliveryDate);
            },

            _formatDayDefiniteDate: function(deliveryDate) {
                return '(' + this._formatDate(deliveryDate, true) + ')';
            },

            _formatNonDayDefiniteDate: function(startDate, endDate) {
                return '(' + this._formatDate(startDate) + ' - ' + this._formatDate(endDate) + ')';
            },

            _formatDate: function(date, wantTime) {
                var d = moment.utc(date);
                return d.format("ddd, Do") + ((wantTime && d.hour() > 0) ? ' ' + d.format('h:mm a') : '');
            },

            _findDropPointDeliveries: function(providerId) {
                var self = this;
                //var droppointIndex = providerId;
                if (typeof (this._deliveryDroppoints[providerId]) !== "undefined") {
                    var results = [];
                    for (var service in this._deliveryDroppoints[providerId]) {
                        var item = this._deliveryDroppoints[providerId][service];
                        /*var obj = {
                            id: item.service.id,
                            methodTitle: item.service.methodTitle,
                            price: item.service.price,
                        };*/
                        if (item.service.maxDD == item.service.minDD) {
                            // day definite
                            var startDate = new Date(item.deliveryDate);
                            item.deliveryDateRange = this._formatDayDefiniteDate(item.service.deliveryTimeTo);
                        }
                        else {
                            // non day definite
                            var startDate = new Date(item.deliveryDate);
                            var endDate = new Date(startDate);
                            endDate.setDate(endDate.getDate() + (item.service.maxDD - 1));
                            item.deliveryDateRange = this._formatNonDayDefiniteDate(startDate, endDate);
                        }
                        results.push(item);
                    }
                    return results;
                } else {
                    return null;
                }
            },

            //Make a lookup for droppoint providers, allowing all shipping methods for that provider to be returned
            _indexDropPointProviders: function (deliveryDayArray) {
                var self = this;
                //For each item in the array of delivery days,
                deliveryDayArray.forEach(function (day) {
                    //For each rate on the day,
                    day.rates.forEach(function (service) {
                        //If this is a droppoint,
                        if (service.serviceType.type === "dmStandardDropPoint") {
                            //For each droppoint provider that covers this droppoint,
                            service.serviceType.droppointProviders.forEach(function (provider) {                              
                                //If this is a provider not yet seen, instantiate with a blank object
                                if (typeof (self._deliveryDroppoints[provider.id]) === "undefined") {
                                    self._deliveryDroppoints[provider.id] = {};
                                }
                                //If this is a service not known for this provider, add it    
                                if (typeof(self._deliveryDroppoints[provider.id][service.id]) === "undefined") {
                                    self._deliveryDroppoints[provider.id][service.id] = {
                                        deliveryDate: day.deliveryDate,
                                        service: service
                                    };
                                }
                                //Else if this is a known service for this provider,
                                else {
                                    //If this new one has an earlier delivery date, use that one
                                	var oldDay = new Date(self._deliveryDroppoints[provider.id][service.id].deliveryDate);
                                	var thisDay = new Date(day.deliveryDate);
                                	if (oldDay.getTime() > thisDay.getTime()) {
                                        self._deliveryDroppoints[provider.id][service.id] = {
                                            deliveryDate: day.deliveryDate,
                                            service: service
                                        };
                                    }
                                }
                            });
                        }
                    });
                });
            },

            // find the earliest of each non-day-definite service
            _getStandardServices: function () {
                var self = this;
                var results = [];
                var services = {};

                //For each non day definite item,
                this._data.nonDayDefinite.forEach(function (day) {
                    //For each rate on the day,
                    day.rates.forEach(function (serviceItem) {
                        //If this is a standard rate,
                        if (serviceItem.serviceType.type === "dmStandard") {
                            //If this is a provider not yet seen, instantiate 
                            if (typeof (services[serviceItem.id]) === "undefined") {
                                services[serviceItem.id] = {
                                    deliveryDate: day.deliveryDate,
                                    service: serviceItem
                                };
                            }                         
                            //If this new one has an earlier delivery date, use that one
                            var oldDay = new Date(services[serviceItem.id].deliveryDate);
                            var thisDay = new Date(day.deliveryDate);
                            if (oldDay > thisDay) {
                                services[serviceItem.id].deliveryDate = day.deliveryDate;
                            }
                            services[serviceItem.id].selected = services[serviceItem.id].selected || serviceItem.selected;
                        }
                    });
                });

                //Now convert the index into an array
                for (var service in services) {
                    var item = services[service];
                    var obj = {
                        id: item.service.id,
                        methodTitle: item.service.methodTitle,
                        price: item.service.price,
                        localizedPrice: item.service.localizedPrice,
                        _originalMethodObject: item.service
                    };
                    // non day definite
                    var startDate = new Date(item.deliveryDate);
                    var endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + (item.service.maxDD - 1));
                    obj.deliveryDateRange = this._formatNonDayDefiniteDate(startDate, endDate);
                    obj.deliveryTimeFrom = endDate.getTime();
                    results.push(obj);
                }

                if (this.config.deliveryPreferences) {
                    var sortFunction = this._getDeliveryMethodSortFunction();
                    results = results.sort(sortFunction);
                }
                return results;
            },
            
            _getDeliveryRateById: function (id) {
                var combinedRateGroups = this._data.dayDefinite.concat(this._data.nonDayDefinite);
                var rates = [];
                combinedRateGroups.forEach(function (group) {
                    rates = rates.concat(group.rates);
                });
                var resultList = rates.filter(function (rate) {
                    return rate.id == id
                });
                if (resultList.length) {
                    return resultList[0];
                }
                else return null;
            },

            _unselectMethod: function() {
                var methods = this.standardRates;
                methods.forEach(function (item) {
                    item.selected = false;
                });
            },

          
            setDeliveryMethodEvent: function (e) {
                //if (e.target.checked) {                    
                    this.setDeliveryMethod(e.target.id);
                //}
            },

            onSelectTab: function (e) {
                if (e.detail.item.id === "pageCalendar") {
                    this.onShowPage_Calendar();
                }
                else if (e.detail.item.id === "pageStandard") {
                    this.onShowPage_Standard();
                }
                else if (e.detail.item.id === "pageDroppoints") {
                    this.onShowPage_Droppoints();
                }
                else {
                }
            },

            refreshShippingTab: function () {
                if (this.$.pages.selected === 0) {
                    this.onShowPage_Calendar();
                }
                else if (this.$.pages.selected === 1) {
                    this.onShowPage_Droppoints();
                }
                else if (this.$.pages.selected === 2) {
                    this.onShowPage_Standard();
                }
                else {
                }
            },

            showPage_Calendar: function () {
                this.$.pages.select(0);
                this.onShowPage_Calendar();              
            },

            onShowPage_Calendar: function(preselect) {
                this._showingDroppoints = false;
            },

            showPage_Standard: function (preselect) {
                this.$.pages.select(2)           
			},

			onShowPage_Standard: function(preselect) {
			    this._showingDroppoints = false;
  			    this.$.standardRatesTemplate.render();
			},

			showPage_Droppoints: function () {
			    if (this.$.pages.selected !== 1) 
			        this.$.pages.select(1);
			    else if (!this._showingDroppoints) 
			        this.onShowPage_Droppoints();
            },

            onShowPage_Droppoints: function() {
            	if (this._map) {
                    this._showingDroppoints = true;
                    this._showDropPointsView();
                }
            },

			_onClickFavAddress: function (e) {
			    var addr = e.currentTarget;
			    var self = this;
			    this.requestDropPointsByAddress(addr.addressData);
			},

            /*
			_onSelectFavDroppoint: function (dp) {
			    var geoLocation = {
			        lat: dp.currentTarget.droppointData.geoLocation.coordinates.latitude,
			        lng: dp.currentTarget.droppointData.geoLocation.coordinates.longitude
			    };
			    this._panToGeoLocation(geoLocation);
			},*/

			_panToGeoLocation: function (geoLocation) {
                this._map.panTo(geoLocation);
                this._mapViewPort = [[ geoLocation.lng - 0.01,geoLocation.lat - 0.01], [geoLocation.lng + 0.01, geoLocation.lat + 0.01]];
			},

			_panToPlace: function (e) {
			    this.gotoGoogleAddress(e.detail);
			},

            gotoGoogleAddress: function(details) {
			    var googleAddressComponents = details.address_components; 
			    var googleAddress = googleAddressComponents.reduce(function(accumulator, item){
			        item.types.forEach(function(itemType) {
			            if (itemType == 'country') {
			                accumulator.country = item.short_name;
			            }
			            else {
			                accumulator[itemType] = item.long_name;
			            }
			        });
			        return accumulator;
			    }, {});
			    var addr = {
			        addressLineCollection: [(((googleAddress.premise ? (googleAddress.premise + " ") : "") + (googleAddress.street_number ? (googleAddress.street_number + " ") : "") + (googleAddress.route || googleAddress.locality || "")) || ""),
                 			                 (googleAddress.neighbourhood || googleAddress.sublocality_level_2 || "")],
			        town: googleAddress.locality || googleAddress.postal_town || "",
			        postCode: googleAddress.postal_code || "",
			        countryCode: { code: googleAddress.country },
                    lat: details.geometry.location.lat(),
                    lng: details.geometry.location.lng(),
			    };
			    this.requestDropPointsByAddress(addr);
			},

            addressLookupLocation: null,
			_panToPlaceOnClick: function (e) {
			    var addr = this.addressLookupLocation;
			    if (addr) {
			        this.gotoGoogleAddress(addr);
			    }
			},

            enableClickAndCollect: function(enable) {
                enable = true; //TODO: Forcing on for the time being. Remove this line when the travelling user UI is to be finished.
                if (enable) {
                    this.$.availableDropPoints.classList.remove('hidden');
                    this.$.noDropPoints.classList.add('hidden');
  
                }
                else {
                    this.$.availableDropPoints.classList.add('hidden');
                    this.$.noDropPoints.classList.remove('hidden');
                }
            },

            enableCalendarDelivery: function(enable) {
                if (enable) {
                    this.$.calendardelivery_tab.classList.remove('hidden');
                }
                else {
                    this.$.calendardelivery_tab.classList.add('hidden');
                }
            },
            
            hasLatLng: function (item) {
                //return true;
                return (item.lat && item.lng)
            }
        });

        function isNull(a, b) {
            if (a == null || typeof (a) == "undefined" || a == "" || a.length == 0) return b
            else return a;
        }


        /* An InfoBox is like an info window, but it displays
         * under the marker, opens quicker, and has flexible styling.
         * @param {GLatLng} latlng Point to place bar at
         * @param {Map} map The map on which to display this InfoBox.
         * @param {Object} opts Passes configuration options - content,
         * offsetVertical, offsetHorizontal, className, height, width
         */

        function InfoBox(opts) {
            google.maps.OverlayView.call(this);
            this.latlng_ = opts.latlng;
            this.map_ = opts.map;
            this.content = opts.content;
            this.contentOrigin = this.content.parentNode;
            this.offsetVertical_ = -195;
            this.offsetHorizontal_ = 5;
            //this.height_ = 165;
            this.width_ = 240;

            this.setMap(this.map_);
        }
        /* InfoBox extends GOverlay class from the Google Maps API
         */
        InfoBox.prototype = new google.maps.OverlayView();
        /* Creates the DIV representing this InfoBox
         */
        InfoBox.prototype.remove = function () {
            if (this.content) {
                this.contentOrigin.appendChild(this.content);
            }
            this.setMap(null);
        };
        /* Redraw the Bar based on the current projection and zoom level
         */
        InfoBox.prototype.draw = function () {
            // Creates the element if it doesn't exist already.
            this.createElement();
            if (!this.content) return;
            // Calculate the DIV coordinates of two opposite corners of our bounds to
            // get the size and position of our Bar
            var pixPosition = this.getProjection().fromLatLngToDivPixel(this.latlng_);
            if (!pixPosition) return;

            var posX = pixPosition.x + this.offsetHorizontal_;
            var posY = pixPosition.y + this.offsetVertical_ + 85;//- (this.height_/2);

            // Now position our DIV based on the DIV coordinates of our bounds
            this.content.style.width = this.width_ + "px";
            this.content.style.left = (posX - 32) + "px";
            this.content.style.height = this.height_ + "px";
            this.content.style.top = (posY + 70) + "px";
            this.content.style.display = 'block';
            this.content.style.position = 'relative';
            
            this.content.style['z-index'] = 99;
        };

        InfoBox.prototype.createElement = function () {
            var panes = this.getPanes();
            panes.floatPane.appendChild(this.content);
        }

    </script>
</dom-module>

<link rel="import" href="../../polymer/polymer.html" />

<link rel="import" href="../../polymer-cookie/polymer-cookie.html" />
<link rel="import" href="../../paper-tabs/paper-tabs.html" />
<link rel="import" href="../../iron-pages/iron-pages.html" />

<link rel="import" href="../p4m-spinner/p4m-spinner.html" />
<link rel="import" href="../p4m-shared/p4m-shared.html" />
<link rel="import" href="../p4m-profile/p4m-profile.html" />
<link rel="import" href="../p4m-api/p4m-api.html" />
<link rel="import" href="../p4m-cart/p4m-cart.html" /> 
<link rel="import" href="../p4m-order-summary/p4m-order-summary.html" />
<link rel="import" href="../p4m-address-list/p4m-address-list.html" />
<link rel="import" href="../p4m-purchase/p4m-purchase.html" />
<link rel="import" href="../p4m-purchase/p4m-purchase-btn.html" />
<link rel="import" href="../p4m-card-list/p4m-card-list.html" />
<link rel="import" href="../p4m-delivery/p4m-delivery.html" />
<link rel="import" href="../p4m-order-text/p4m-order-text.html" />
<link rel="import" href="../p4m-overlay/p4m-general-fault.html" />

<link rel="import" href="../p4m-discount-input/p4m-discount-input.html" />
<link rel="import" href="../p4m-discount-list/p4m-discount-list.html" />

<link rel="import" href="../gfs-checkout-widget/gfs-checkout-widget.html" />
<link rel="import" href="../address-lookup-field/address-lookup-field.html" />  


<link rel="import" href="../p4m-imports/p4m-imports.html" />  
 
<link rel="stylesheet" href="../p4m-shared/p4m.css" />

<dom-module id="p4m-checkout">

    <template>

        <p4m-api id="p4mCheckoutApi" ssl="true" on-noservice="onP4mNoService" host-base-domain="parcelfor.me" host-type="{{hostType}}" version="v2"></p4m-api>
        <p4m-api id="localApi" is-local="true"></p4m-api>
        <div id="container" class$="{{_changeIndicatorClass}}">

            <div id="topPanel" class="topPanel">
                <img class="p4m-register-logo" src="../p4m-shared/img/P4M-Top-Header.png" id="peli-icon-header" />
                <!-- Not using due to Variable font baselines screwing alignment across browsers, Including in logo image instead.
                <h2>Checkout &amp; Delivery</h2> -->
                <div class="flex-spacer"></div>
                <div><span class="font-weight-light">Welcome,</span> </div>
                <p4m-profile mode="basic"></p4m-profile>
            </div>

            <div id="panelContainer" class="horizontal layout">
                <div id="detailPanel" class="p4m-panel flex-2">                   
                    <paper-tabs selected="{{selectedTab}}" no-bar>
                        <paper-tab>My Order<p4m-spinner species="progress" id="myorder_spinner"></p4m-spinner></paper-tab>
                        <paper-tab>Addresses<p4m-spinner species="progress" id="addresses_spinner"></p4m-spinner></paper-tab>
                        <paper-tab>Delivery Options<p4m-spinner species="progress" id="delivery_spinner"></p4m-spinner></paper-tab>
                        <paper-tab>Payment Options<p4m-spinner species="progress" id="payment_spinner"></p4m-spinner></paper-tab>                  
                    </paper-tabs>
                    <iron-pages id="p4mPages" selected="{{selectedTab}}" on-iron-select="_onSelectTab">                   
                        <iron-page id="cartPage">                       
                            <p4m-cart id="cart" cart-data="{{cartData}}"></p4m-cart>                         
                        </iron-page>
                        <iron-page id="addressPage">
                            <p4m-address-list id="addressList" address-list-data="{{consumerData.addresses}}" cart-data="{{cartData}}" on-select="onSelectAddressFromList" on-add="onAddAddress" on-update="onUpdateAddress"></p4m-address-list>
                        </iron-page>
                        <iron-page id="deliveryPage">
                            <div id="shippingSelector" class="hidden">

                                <gfs-checkout id="gfsCheckoutWidget" on-session-expiry="onGfsSessionExpiry" access-token="{{gfsAccessToken}}"  on-selectedservicechanged="onGfsServiceChanged" on-noservice="onGfsNoService" delivery-preferences="{{deliveryPreferences}}" consumer-addresses="{{consumerData.addresses}}" ></gfs-checkout>
                            </div>
                            <div id="noShippingWarning">
                                Please enter an address to continue.
                            </div>

                            <template is="dom-if" if="{{useGfsCheckout}}">
                            </template>
                        </iron-page>
                        <iron-page id="cardPage">
                            <p4m-card-list id="cardList" consumer-data="{{consumerData}}" cart-data="{{cartData}}" platform="{{hostType}}" on-selected="onSelectPaymentMethod" on-gotnewcard="onGotNewCard"></p4m-card-list>
                        </iron-page>

                    </iron-pages>
                </div>
                <div id="summaryPanel" class="p4m-panel smallSummary flex-1">
                    <p4m-order-summary id="orderSummary" cart-data="{{cartData}}"></p4m-order-summary>
                    <p4m-purchase id="p4mPurchase" cart-data="{{cartData}}" on-payment-complete="onPaymentComplete" on-request-payment-method="goToPaymentMethods" use-paypal="{{usePaypal}}" selected-card="{{selectedCard}}" use-paypal="true"></p4m-purchase>
                    <div id="downloadAppAd">
                        <p class="p4m-info">View and track your purchases in the free P4M App! Get it from your app store now.</p>
                    </div>
                </div>
            </div> 


            <footer id="footerpPanel" class$="footerPanel {{_changeIndicatorClass}}">
                
                <p4m-order-text cart-data="{{cartData}}" consumer-data="{{consumerData}}" on-request-address="goToAddresses"></p4m-order-text>
                <p4m-purchase-btn id="p4mPurchaseBtn"></p4m-purchase-btn>
            </footer>

        </div>

        <p4m-general-fault id="generalFault" no-cancel-on-outside-click with-backdrop></p4m-general-fault>
        <p4m-overlay id="screenOverlay" no-cancel-on-outside-click with-backdrop></p4m-overlay>

        <polymer-cookie id="sessionCookie" name="CartId"></polymer-cookie>

        <!--             
        <polymer-cookie id="p4mDefaultPostCode" name="p4mDefaultPostCode"></polymer-cookie>
        <polymer-cookie id="p4mDefaultCountry" name="p4mDefaultCountry"></polymer-cookie>
        -->

        <style include="p4m-shared">
            p4m-general-fault {
               --p4m-general-fault-h1-border: 5px solid red;
                --p4m-general-fault-h1-border: #fff;
                --p4m-general-fault-h1-font-size: 48px;
                --p4m-general-fault-h1-line-height: 1em;
                --p4m-general-fault-h1-margin-bottom: .425em;
            }
            iron-overlay-backdrop {
                --iron-overlay-backdrop-background-color: #37a553;
                --iron-overlay-backdrop-opacity: 0.95;
            }
            .litte-spinner {
                width: 20px;
                height: 20px;
                position: relative;
                xtop: 65px;
                xleft: 40%;
                margin-left: auto;
            }
            paper-tab {
                border-right: 1px solid rgba(255,255,255,0.2);
                padding: 0;
            }
            paper-tab:first-of-type {
                border-left: none;
            }
        </style>

    </template>





    <script>

        Polymer({
            is: "p4m-checkout",

            properties: {
                sessionId: {
                    type: String
                },
                consumerData: {
                    type: Object,
                    notify: true
                    //observer: "onConsumerDataChange"
                },              
                cartData: {
                    type: Object,
                    notify: true,
                },
                isNew: {
                    type: Object,
                    value: false
                },
                deliveryData: {
                    type: Object,
                    notify: true
                },
                selectedTab: {
                    type: Number,
                    value: 0
                },
                currency: {
                    type: String,
                    value: "GBP"
                },
                selectedCard: {
                    type: Object
                },
                hostType:{
                    type: String,
                    value: "dev" //default value
                },
                useGfsCheckout: {
                    type: Object,
                    value: false
                },
                usePaypal: {
                    type: Object,
                    value: false,
                    notify: true
                },
                gfsAccessToken: {
                    type: String
                },
                gfsData: {
                    type: String
                },
                initialPostCode: {
                    type: String,
                    value: "W1A 0AX"
                },
                initialCountryCode: {
                    type: String,
                    value: "GB"
                },
                localCountries: {
                    type: Array,
                    value: []
                },
                onSessionExpiry: {
                    type: String
                },
                _notUseGfsCheckout: {
                    type: Object,
                    value: true
                },
                _changeTimer: {
                    //Timer object to allow sending of changes once user has finished interaction
                    type: Object
                },
                _changeIndicatorClass: {
                    type: String,
                    value: "not_changed"
                },
                _loadingStack: {
                    type: Number,
                    value: 0
                }
                
            },
            observers: [
                //"onCartDiscountChange(cartData.discounts.*)"
               "onCartItemsChange(cartData.items.*)",
               //"onCartAddressSelect(cartData.addressId)"
               "onConsumerAddressChange(consumerData.addresses.*)"
            ],

            ready: function()
            {
                console.log("P4M Checkout ready", new Date().getTime());
                //console.log('Async:',async);
                var self = this;
                this.Tabs = { "ORDER": 0, "DELIVERY": 1, "ADDRESS": 2, "PAYMENT": 3 };
                this._notUseGfsCheckout = !this.useGfsCheckout;

                if (!this.sessionId) {
                    this.sessionId = this.$.sessionCookie.readCookie();
                }

                this.init();
            },

            init: function (finalCallback) {
                var self = this;
                self.initialising = true;
                console.log('Initialising...');
                window.addEventListener('discount', this.onDiscount.bind(this));
                window.addEventListener('discountdelete', this.onDiscountDelete.bind(this));

                self.sessionAddressId = hashThis(this.sessionId);

                //Set local countries -- this determins if Calendar and Click and Collect tabs are available
                this.localCountries.push(this.initialCountryCode);
                for (var i=0; i<this.localCountries.length; i++) {
                    this.localCountries[i] = this.localCountries[i].toLowerCase();
                }

                async.series(
                    [
                        function _consumer(callback) {
                            self._getConsumer(callback)
                        },

                        //Get local cart
                        function _localCart(callback) {
                            console.log('_localCart()');
                            if (self.sessionId) {
                                self.getLocalCart(function (err) {
                                    if (err) {
                                        callback(err)
                                    }
                                    else {
                                        console.log('init: First updateP4mCart() start');
                                        self.updateP4mCart(function(err) {
                                            console.log('init: First updateP4mCart() finished');
                                            callback(err);
                                        });
                                    }
                                });
                            }
                            else {
                                callback("No cart");
                                //self.getP4mCart(callback);
                            }
                        },
                        /*
                        function _setAddress(callback) {
                            if (self.isNew) {
                                self.preselectAddress(callback)                                
                            }

                            else 
                                callback(null);
                        }*/
                    ],
                    function (err) {

                        if (err) {
                            self.initialising = false;
                            console.error(err);
                            console.log('...Initialisation aborted.');
                            throw err;
                        }

                        async.series(
                        [

                            //Send info from cart and consumer to GFS
                            function _gfs(callback) {
                                self.initialising = false;
                                console.log('_gfs()');
                                self._runGFS_IfReady(callback);

                            },

                            //function _p4mCart(callback) {
                            //    //self.initialising = true;
                                
                            //    console.log('init: Second updateP4mCart() start - still required??');
                            //    //self.preselectDeliveryMethod();

                            //    self.updateP4mCart(function(err) {//This will set IsNew to false
                            //        console.log('init: Second updateP4mCart() complete');
                            //        callback(err);
                            //    }); 
                            //}
                        ],
                        function (err) {
                            if (err) {
                                console.error(err);
                                console.error("Cancelled initialisation.");
                            }
                            self.initialising = false;
                            console.log('...Initialisation complete.');
                        })
                    }
                )
                this.$.p4mPurchase.beforePurchase = this.$.gfsCheckoutWidget._closeReq.bind(this.$.gfsCheckoutWidget);
            },

            _getConsumer: function (callback) {
                var self = this;
                if (!callback)
                    callback = function () { };


                self.$.p4mCheckoutApi.call('consumer', null, null, function (err, data) {
                    if (!data.success) {
                        callback(data.error);
                    }
                    else {
                        self.set('consumerData', data.consumer);
                        if (data.consumer.hasInstalledApp)
                            self.$.downloadAppAd.classList.add("hide");
                        callback(err, data);
                    }
                });
            },


            //Send all cart information to shipping plugin
            _gfsCurrentAddrId: null,
            _updateGfs: function (callback) {
                if (!callback) {
                    callback = function(){};
                }

                if (!this.cartData || !this.cartData.items || this.cartData.items.length === 0) {
                    callback();
                    return;
                }

                var self = this;
                
                this._gfsCurrentAddrId = this._gfsCurrentAddrId || this.cartData.addressId || this.consumerData.prefDeliveryAddressId;
                this._updateUiForAddress(this.getAddressById(this._gfsCurrentAddrId));

                var orderValue = 0.0;
                this.cartData.items.forEach(function (item) {
                    orderValue += item.qty * item.price;
                });
                if (orderValue <= 0.0) {
                    callback();
                    return;
                }

                var addrPrefs = this.consumerData.deliveryPreferences ? this.consumerData.deliveryPreferences.split(',') : null;
                var gfsPostConfig = {
                    countryCode: "GB",
                    town: "London",
                    Town: "London",
                    postCode: "SW1A 0AA",
                    addressLines: ["House of Commons", "Houses of Parliament"],
                    contactEmail: "nocontact@nocontact.com",
                    recipientFirstName: this.consumerData.familyName,
                    recipientLastName: this.consumerData.givenName,
                    recipientTitle: this.consumerData.title || "",
                    favDropPoints: self._getPreferredDropPoints() || [],
                    favAddresses: self._getPreferredAddresses() || [],
                    defaultAddress: p4mAddressToGfsAddress(self.getAddressById(this.consumerData.prefDeliveryAddressId)),
                    cartValue: orderValue,
                    addressPreferences: addrPrefs,
                    deliveryPreferences: {
                        preferSoonest: this.consumerData.preferSoonestDelivery
                    }
                };

                //Make an object containing everything needed for GFS Checkout to re-select my previous delivery options
                var selection = null;
                if (!this.isNew && self.cartData.addressId) {
                    var addr = self.getAddressById(self.cartData.addressId);
                    var dropPointId = addr ? addr.dropPointId : null;
                    selection = {
                        dropPointId: dropPointId,
                        deliveryMethodId: self.cartData.serviceId,
                        address: p4mAddressToGfsAddress(addr) || null,
                        deliveryDate: new Date(self.cartData.expDeliveryDate)
                    }
                    //selection = null;
                }
                this.toggleLoading(true);
                this.$.gfsCheckoutWidget.init(gfsPostConfig, selection, function(err) {
                    self.toggleLoading(false);
                    callback(err);
                });

            },

            debug: function(e) {
                console.log("p4m-checkout debug", this.cartData);
            },

            getLocalCart: function (callback) {
                var self = this;
                this.$.localApi.call('getP4MCart', null, null, function (err, data) {
                    if (err) {
                        console.log("getLocalCart() error:", err);
                        callback(err);
                    }
                    else {
                        self.isNew = data.isNew;
                        self.cartData = data.cart;
                        callback(err, data.cart);
                    }
                });
            },

            getP4mCart: function (callback) {
                this.$.p4mCheckoutApi.call('currentCart', { sessionId: this.sessionId }, null, this.onRemoteCartData.bind(this, callback));
            },

            sendCartItemChanges: function () {          
                //Send changes to local API, then to P4m

                var self = this;
                var changes = [];

                for (var sku in this.$.cart.changes) {
                    if (this.$.cart.changes[sku] === "" || this.$.cart.changes[sku] === null) {
                        this.$.cart.changes[sku] = 0;
                    }
                    changes.push({ItemCode: sku, Qty: this.$.cart.changes[sku]});
                }
                if (changes.length > 0) {
                    
                    var orderValue = 0.0;
                    for (var item in this.$.cart.items) {
                        orderValue += item.qty * item.price; 
                    }

                    //this.$.gfsCheckoutWidget.setGfsOrderValue(orderValue, function () {
                    //self._showAsLoadingShipping(true);
                    self.toggleLoading(true);

                    self.$.localApi.call('itemQtyChanged', {}, changes, function (err, newCartTotals) {
                        //console.log("Called local api itemQtyChanged");
                        console.log("sendCartItemChanges(): itemQtyChanged: new cart totals", newCartTotals);
                        self.$.cart.clearChanges();
                        self.updCartTotals(newCartTotals, function (err) { //This will trigger GFS to trigger updateP4mCart, so no need to call it in the callback here. Commented out.
                            self.toggleLoading(false);
                            self.set("cartData.discounts", newCartTotals.discounts);
                            /*self.updateP4mCart(function(err) {
                                self.toggleLoading(false);
                                //callback(err);
                            });*/
                            
                        });

                    });
                    //})

                }
                else {
                    //console.log("No changes to send");
                }
            },

            //Send new total to shipping module and ask for new shipping price etc
            updCartTotals: function (newCartTotals, callback, updDiscount) {
                // this gets called when an item qty is changed, or when a discount is changed
                this.cartData.tax = newCartTotals.tax || 0;
                this.cartData.shippingAmt = newCartTotals.shipping || 0;
                this.cartData.total = newCartTotals.total || 0;
                if (!updDiscount && this.cartData.total > 0)
                    this._updateGfs(callback);
                else 
                    this.updateP4mCart(callback);
            },

            _showAsLoadingShipping: function(loading) {
                this.$.delivery_spinner.active = loading;
            },
            
            _toggleAddressesLoading: function(loading) {
                this.$.addresses_spinner.active = loading;  
            },


            toggleLoading: function (loading) {
                var showAsLoading;
                if (loading) {
                    this._loadingStack ++;
                }
                else {
                    this._loadingStack --;
                }
                showAsLoading = (this._loadingStack > 0);

                if (showAsLoading) {
                    this.$.screenOverlay.open();
                    this.$.orderSummary.showAsLoading();
                    this._showAsLoadingShipping(this.cartData && this.cartData.total > 0);
                    this._toggleCartEditing(false);

                    //this.$.p4mPurchase.setLoadingState(true);
                }
                else {
                    this.$.screenOverlay.close();
                    this.$.orderSummary.showAsLoaded();
                    this._showAsLoadingShipping(false);
                    this._toggleCartEditing(true);
                    //this.$.p4mPurchase.setLoadingState(false);
                }

            },

            _toggleCartEditing: function(allowEditing) {
                this.$.cart.toggleEditing(allowEditing);
            },

            updateP4mCart: function (callback) {
                //console.log("updateP4mCart():", new Error().stack);
                //Send changes to P4M
                if (!callback) {
                    console.warn('updateP4mCart: no callback');
                    callback = function () { };
                } 
                /*if (this.updating) {
                    callback(null);
                    return;
                }*/
                console.log('updateP4mCart()');
                //console.trace();
                this.updating = true;
                try {
                   
                    var self = this;
                    var cartMessage =
                    {
                        "sessionId": this.sessionId,
                        "clearItems": (!this.cartData.id), //true, // are we always replacing the whole cart? or ClearItems = this.cartData.Id === null; ??
                        "cart": this.cartData
                    };

                    this.toggleLoading(true);
                    this.$.p4mCheckoutApi.call('postCart', null, cartMessage, function (err, data) {
                        self.updating = false;
                        if (err) {  
                            //This is a workaround. Need to either stop the double-post, or fix the 404 response to them.
                            /*console.warn('An error occurred while updating ParcelForMe:', err);
                            console.log('Stack:', new Error().stack);
                            self.onRemoteCartData.bind(self)({Cart:self.cartData}, callback);  //TODO: Fix double-post error causing 404 in P4M back end, so we can stop suppressing errors here*/

                            callback(err);
                        }
                        else {
                            self.onRemoteCartData.bind(self)(data, callback);
                        }
                    });
                }
                catch (e) {
                    this.updating = false;
                }


                
            },
            //lastSelectedAddrId: '', // record the last selected address for switching between drop points and delivery addrs

            onRemoteCartData: function (data, callback) {
                console.log('onRemoteCartData()');
                this.toggleLoading(false);
                if (!data.success) {
                    console.error(data.error);
                    callback(data.error)
                }
                else {
                    
                    if (!data.cart || !data.cart.items || data.cart.items.length === 0) {

                        window.location.reload(true);
                    }                  
                    else {
                        this.cartData = data.cart;
                        this.isNew = data.isNew;
                        /*var address = this.getAddressById(this.cartData.AddressId);
                        if (address && address.AddressType == "Address") {
                            this.lastSelectedAddrId = data.Cart.AddressId;
                        } */                                                     
                    }
                    callback(null);
                }                                     
            },

            /*
            onCartData: function (data, callback) {
                this.toggleLoading(false);
              
                if (data.Success) {
                    this.cartData = data.Cart;
                    callback(null, this.cartData);
                }
                else {
                    console.error(data.Error);
                    callback(data.Error);
                }
                
                //this.$.p4mPurchase.updateUi();
            },*/

            onCartItemsChange: function (e) {
                console.log('p4m-checkout: onCartItemsChange()');//, JSON.stringify(e));
                //If this is a valid change record,
                var beforeHash = JSON.stringify(e.base);
                var afterHash = JSON.stringify(e.value);
                if (e.path && beforeHash !== afterHash ) {
                    //Start timer, then send changes.
                    //If more changes are detected while the timer is active, reset the timer.
                    console.log("onCartItemsChange: Preparing to send cart changes");
                    if (this._changeTimer) window.clearTimeout(this._changeTimer);
                    this._changeTimer = window.setTimeout(this.sendCartItemChanges.bind(this), 2000);
                }
                else
                {
                    console.log("onCartItemsChange: No cart changes");
                }
            },

            onConsumerAddressChange: function (e) {
                this._runGFS_IfReady();
            },

            _runGFS_IfReady: function (callback) {
                var shouldShow = this._readyForShippingSelector();
                this._ensureShippingVisible(shouldShow);
                if (shouldShow && this._gfsCurrentAddrId != this.consumerData.prefDeliveryAddressId) {
                    this._updateGfs(callback);
                }
            },

            _ensureShippingVisible: function (show) {
                if (show) {
                    this.$.noShippingWarning.classList.add('hidden');
                    this.$.shippingSelector.classList.remove('hidden');
                }
                else {
                    this.$.noShippingWarning.classList.remove('hidden');
                    this.$.shippingSelector.classList.add('hidden');
                }
            },

            _readyForShippingSelector: function () {
                if (this.cartData && this.consumerData.prefDeliveryAddressId) {
                    return this.getAddressById(this.consumerData.prefDeliveryAddressId);
                }
                return false;
            },

            //Take data from shipping selector representing selected shipping options
            //For example output, see gfs-checkout event selectedservicechanged
            //WARNING: Nothing in this function should send messages to the shipping selector or an endless feedback loop will ensue!
            currentService: {},
            updateShippingService: function (data, callback) { //service, shipping, expDeliveryDate, collectPoint) {
                var self = this;
                if (!callback) {
                    throw "updateShippingService(): No callback";
                }
                //if (this.updatingShipping) {
                if (false) {
                    callback(null);
                }
                else {
                    this.updatingShipping = true;
                    //If nothing has changed, exit
                    if (this.currentService.shipping === data.shipping &&
                        this.currentService.collectionPoint === data.collectionPoint &&
                        this.currentService.service === data.service &&
                        this.currentService.serviceId === data.serviceId &&
                        this.currentService.expDeliveryDate === data.expDeliveryDate) {
                        console.warn("updateShippingService(): Nothing has changed")
                        this.updatingShipping = false;
                        callback(null);                       
                    }
                    else {
                        var addr = this.consumerData.addresses.find(a => a.id === this.cartData.addressId);
                        var shippingDetails = { 'service': data.service, 'amount': data.shipping, 'dueDate': data.expDeliveryDate, 'address': addr };
                        // got new shipping details so we need to get updated tax from the host
                        this.$.localApi.call('updShippingService', null, shippingDetails, function (err, cartTotals) {
                            if (err) {
                                console.error("localApi updShippingService error: ", err);
                                callback(err);
                            }
                            else {
                                this.currentService = data;
                                self.set('cartData.carrier', data.carrier);
                                self.set('cartData.shippingAmt', data.shipping);
                                self.set('cartData.serviceName', data.service);
                                self.set('cartData.serviceId', data.serviceId);
                                self.set('cartData.dropPointId', data.collectionPoint);
                                self.set('cartData.expDeliveryDate', data.expDeliveryDate);
                                self.set('cartData.tax', cartTotals.tax || 0);
                                self.set('cartData.total', cartTotals.total || 0);
                                if (data.collectionPoint) {
                                    self.selectCollectPoint(data.provider, data.providerId, data.collectionPoint, data.deliveryAddress, data.companyName, function (err) {
                                        self.updateP4mCart(function (err) {
                                            self.updatingShipping = false;
                                            callback(err);
                                        });
                                    });
                                }
                                else if (data.deliveryAddress.id && data.deliveryAddress.id !== self.cartData.addressId) {
                                    console.log("update shipping addr: ", addr);
                                    self.selectDeliveryAddress(data.deliveryAddress.id, false /*Not updating GFS*/, function (err) {
                                        self.updateP4mCart(function (err) {
                                            self.updatingShipping = false;
                                            callback(err);
                                        })
                                    });
                                }
                                else {
                                    // something has changed on the cart so we need to update it
                                    console.log("updating cart because service or address has changed");
                                    self.updateP4mCart(function (err) {
                                        self.updatingShipping = false;
                                        callback(err);
                                    })
                                }
                            }
                        });
                    }
                }

            },


            selectCollectPoint: function (providerName, providerId, collectPointId, collectPointAddress, company, callback) {
                if (!callback) callback = function () { };
                var self = this;
                var result;
                if (!collectPointId) {
                    console.error("No collectPointId");
                    if (callback)
                        callback();
                    return;
                }
               
                var existingDropPoint = this.$.addressList.getDropPointById(collectPointId);
                if (!existingDropPoint || existingDropPoint.unsaved) {
                    var directions = collectPointAddress.directions ? collectPointAddress.directions.split("]").pop() : "";
                    var prefOrder = this.consumerData.addresses.length || 1;
                    var address =
                    {
                        "id": this.sessionAddressId,
                        "addressType": "Collect",
                        "label": providerName,
                        "companyName": company,
                        "specialInstructions": directions,
                        "street1": collectPointAddress.addressLines[0] || "",
                        "street2": collectPointAddress.addressLines[1] || "",
                        "city": collectPointAddress.town,
                        "postCode": collectPointAddress.postCode,
                        "state": collectPointAddress.county,
                        "country": collectPointAddress.country,
                        "countryCode": collectPointAddress.countryCode,
                        "phone": collectPointAddress.phone,
                        "latitude": collectPointAddress.coordinates.latitude,
                        "longitude": collectPointAddress.coordinates.longitude,
                        "dropPointProviderId": providerName,              
                        "dropPointId": collectPointId,
                        "collectPrefOrder": prefOrder,
                        "unsaved": true
                    };
                    self.saveAddress(address, function (err, result) {
                        //debugger;
                        self.set('cartData.addressId', result.address.id);
                        self.notifyPath('cartData.addressId');
                        self.notifyPath('consumerData.addresses');
                        callback(err);
                    });
                            
                }
                else {
                    //TODO: Replace with selectDeliveryAddress?
                    this.set('cartData.addressId', existingDropPoint.id); //collectPointAddress.Id;
                    this.notifyPath('cartData.addressId');
                    result = existingDropPoint;
                    callback(null);
                }
              
            },

            onPaymentComplete: function (e) {
                if (e && e.detail.redirectUrl) {
                    window.location = e.detail.redirectUrl;
                }
            },
            

            onSelectPaymentMethod: function (e) {
                var updCart = this.selectedCard !== undefined && this.selectedCard !== null;
                this.set('cartData.payMethodId', e.detail.id);
                this.selectedCard = e.detail;
                if (updCart) {
                    this.updateP4mCart();
                }
            },

            //onCardHashData: function (data) {
            //    this.set('cardTimestamp', data.Timestamp);
            //    this.set('cardMerchantId', data.MerchantId);
            //    this.set('cardHash', data.Hash);               
            //},

            onDiscount: function (e) {
                var cartDiscount = this.cartData.discounts.find(function (element, index, arr) { return element.code === e.detail.code; }); //TODO: Change to bound function; arrow functions may not work in older browsers
                if (cartDiscount) {
                    if (cartDiscount.description !== e.detail.description ||
                        cartDiscount.amount !== e.detail.amount ||
                        cartDiscount.code !== e.detail.code)
                    {
                        cartDiscount.description = e.detail.description;
                        cartDiscount.amount = e.detail.amount || 0;
                        cartDiscount.code = e.detail.code;
                        this.updCartTotals(e.detail, null, true);
                    }
                }
                else {
                    this.push('cartData.discounts', e.detail);
                    this.updCartTotals(e.detail, null, true);
                }
            },

            onDiscountDelete: function (e) {
                var code = e.detail;              
                var item = this.cartData.discounts.find(function(element, index, arr) { return (element.code === code) });
                if (item) {
                    item.amount = 0;
                    item.description = "Deleted";
                    var self = this;
                    this.$.localApi.call('removeDiscountCode', null, { "discountCode": code }, function (err, response) {
                        if (response && response.success)
                            self.updCartTotals(response, null, true);   // this will upate the cart as well
                    });
                }
            },

            onGotNewCard: function(){
                 this._getConsumer();
            },

            onSelectAddressFromList: function (e) {
                /*if (e.detail.isDelivery && self.cartData.AddressId != e.detail.id) {
                    this.selectDeliveryAddress(e.detail.id, function (err) {
                        if (err) {
                            console.error("onSelectAddressFromList():", err);
                        }
                    });
                }*/


                //TODO: Must set billing address etc
                var self = this;
                if (e.detail) {

                    //If changed billing address, tell P4M
                    if (e.detail.isBilling && self.cartData.billingAddressId != e.detail.id) {
                        self.set('cartData.billingAddressId', e.detail.id);
                        self.updateP4mCart();
                    }
                    //If changed delivery address, tell GFS and P4M
                    else if (e.detail.isDelivery && self.cartData.addressId != e.detail.id) {
                        self.selectDeliveryAddress(e.detail.id, true, function (err) {
                            if (err) {
                                console.error(err);
                            }
                        });                     
                    }
                }
            },

            //TODO: Take an extra parameter: send to GFS
            //This allows two-way binding without feedback loop
            selectDeliveryAddress: function (addressId, sendToGfs, callback) {
                var self = this;
                var address = this.getAddressById(addressId);
                if (!callback) callback = function(){};

                if (!address) {
                    callback("No such address");
                    //return false;
                }
                else {
                    /*if (this.consumerData.prefDeliveryAddressId === null) */
                    this.consumerData.prefDeliveryAddressId = addressId;
                    //self._updateUiForAddress(address);

                    //Send to GFS Checkout and await shipping event
                    //If this is a user-initiated address change, we need to tell GFS and get new shipping details back (via onGfsServiceChanged)
                    if (sendToGfs) {

                        //if (!this._readyForShippingSelector) {
                        //    callback();
                        //    return;
                        //}


                        //CURRENT BUG:
                        //If this conditional line is not here,
                        //  The available shipping options don't change when the address changes
                        //If it is here,
                        //  The newly selected address is not sent to GFS

                        //if (!this.$.gfsCheckoutWidget.initialised) {
                            //this._updateGfs(function(err) {

                                self.$.gfsCheckoutWidget.selectFavAddress(addressId, true, function(err) {
                                    if (!err) {
                                        self._gfsCurrentAddrId = addressId;
                                        self.set('cartData.addressId', addressId); //This allows the address UI to update
                                        self.notifyPath('cartData.addressId');
                                        self._updateGfs(callback);
                                    }
                                });
                            //})
                        //}
                        /*
                        else {
                            this.$.gfsCheckoutWidget.selectFavAddress(addressId, true, function(err) {
                                self.set('cartData.addressId', addressId); //This allows the address UI to update
                                self.notifyPath('cartData.addressId');
                                if (callback) {
                                    callback(null, address);
                                }
                            });
                        }*/
                        

                    }
                    else {
                        this.set('cartData.addressId', addressId); //This allows the address UI to update
                        this.notifyPath('cartData.addressId');
                        callback(null, address);
                    }
                    //callback(null, address);                
                }

            },

            onAddAddress: function (e) {
                this.onUpdateAddress(e);
                /*, function (result) {
                    if (result) {
                        e.detail.markAsBilling();
                    }
                });*/
            },

            saveAddress: function (address, finalCallback) {
                if (!address.addressType) {
                    address.addressType = 'Address';
                }
                var self = this;
                var result = null

                var hasAnAddress = this.consumerData.addresses.length && this.consumerData.addresses.some(function (address) { return address.id && address.id != ""; });
                var existingAddress = hasAnAddress && address.id && address.id != "" && this.getAddressById(address.id);
                var postData =
                {
                    "Address": address,
                    "isPrefDeliveryAddr": !hasAnAddress,
                    "isBillingAddr": !hasAnAddress
                };

                async.series(
                    [
                        function _postAddress(callback) {
                            self.$.p4mCheckoutApi.call("postAddress", null, postData, function (err, data) {
                                result = data;
                                address.id = result.address.id;
                                if (!existingAddress) {
                                    self.push('consumerData.addresses', result.address);
                                }
                                self.$.gfsCheckoutWidget.setFavAddresses(self._getPreferredAddresses())

                                callback(err);
                            });
                        },
                        function _selectAddress(callback) {
                            self.selectDeliveryAddress(result.address.id, true, function(err, data) {
                                //  result = data;
                                callback(err);
                            });
                        }
                    ],
                    function(err) {
                        finalCallback(err, result);
                    }
                )
            },

            onUpdateAddress: function (addressElement) {
                // here we're adding or updating an address only, not setting a default value on the consumer at this stage

                this._toggleAddressesLoading(true);

                var self = this;
                this.saveAddress(addressElement.detail.addressData, function (err, result) {
                    if (err) {
                        self._toggleAddressesLoading(false);
                        throw err;
                    }
                    else {
                        addressElement.detail.addressData.id = result.address.id;
                        self._toggleAddressesLoading(false);
                        self._ensureShippingVisible(true);
                    }
                });

            },

            _updateUiForAddress: function(address) {
                    var localDelivery = this.localCountries && this.localCountries.constructor == Array && this.localCountries.length && (this.localCountries.indexOf(address.countryCode.toLowerCase()) > -1);

                    this.$.gfsCheckoutWidget.enableClickAndCollect(localDelivery);
                    this.$.gfsCheckoutWidget.enableCalendarDelivery(localDelivery);
                    if (!localDelivery) {
                        this.$.gfsCheckoutWidget.showPage_Standard(); //Show the standard tab, which is now the only available one.
                    }
            },
            /*
            preselectDeliveryMethod: function () {
                //Select delivery details based on selected address and user's preferences
                if (!this.consumerData) throw "No consumer data"
                else if (!this.cartData) throw "No cart data";

               
                //this.consumerData.PreferSoonestDelivery = true; //TODO: Remove. This is just here for testing.
                //Rather than opening a page, let's handle this directly.

                if (this.consumerData.PreferSoonestDelivery) {
                    if (this.$.gfsCheckoutWidget) {
                        //this.$.gfsCheckoutWidget.showPage_Calendar(true);
                        this.$.gfsCheckoutWidget._preselectForCalendar();
                    }
                }
                else {
                    if (this.$.gfsCheckoutWidget) {
                        this.$.gfsCheckoutWidget._preselectForStandard();
                        //this.$.gfsCheckoutWidget.showPage_Standard(true);
                    }

                }
               

            },
*/
  

            selectPreferredAddress: function (callback) {
                //If there is a preferred delivery address, select that.
                //PRECONDITION: Consumer data and Cart data exists
                console.log('selectPreferredAddress');
                if (this.consumerData.prefDeliveryAddressId) {
                    this.selectDeliveryAddress(this.consumerData.prefDeliveryAddressId, false, callback);
                }
                else {
                    callback("No preferred address");
                }
            },

            _getPreferredDropPoints: function() {
                return this.consumerData.addresses         
                    .filter(function (item) { return (item.addressType == "Collect" && item.latitude && item.dropPointId) })
                    .map(p4mDroppointToGfsDroppoint);
            },

            _getPreferredAddresses: function (maxItems) {
                var preferredAddressId = this.consumerData.prefDeliveryAddressId;
                return this.consumerData.addresses
                    .filter(function (item, i) { return (item.addressType == "Address") }) //Only addresses, not droppoints
                    .sort(function (a, b) { if (a.id == preferredAddressId) { return -1; } else { return 1 } })
                    .filter(function (item, i) { return (i < (maxItems || 99)) }) //Up to 99 addresses                   
                    .map(p4mAddressToGfsAddress);
            },

            onGfsServiceChanged: function (e) {
                if (this.initialising) {
                    console.warn('onGfsServiceChanged(): not updating while initialising');
                    return;
                }
                else {
                    console.log("p4m widget: onGfsServiceChanged():", e);
                    this.triggerChangeIndicator();
                    this.updateShippingService(e.detail, function () { console.log("onGfsServiceChanged: updateShippingService complete")});
                }
            },

            triggerChangeIndicator: function() {

                this.set("_changeIndicatorClass", "not_changed");
                window.setTimeout(function(){this.set("_changeIndicatorClass", "change")}.bind(this), 10);
                

            },

            onGfsServicePreselect: function (e) {
                this.updateShippingService(e.detail, function () { console.log("onGfsServicePreselect: updateShippingService complete") });
            },

            onGfsNoService: function (e) {
                // this.preselectDeliveryMethod();
                console.error('No GFS service');
                this.showGeneralFault();
            },

            onP4mNoService: function (e) {
                console.error('No P4M service');

                this.showGeneralFault();
            },

            onGfsSessionExpiry: function (e) {
                console.log("GFS Checkout session expired");
                if (this.onSessionExpiry) {
                    window[this.onSessionExpiry]();
                }
                else
                {
                    window.reload();
                }
                
            },

            getAddressById: function(id) {
                if (!this.consumerData) {
                    return null;
                }
                var foundItem = this.consumerData.addresses.find(function(item) { return item.id == id });
                return foundItem;
            },

            goToPaymentMethods: function () {
                this.selectedTab = this.Tabs.PAYMENT;
                this.$.cardList.addNewCard();
            },

            goToAddresses: function () {
                this.selectedTab = this.Tabs.ADDRESS;
                this.$.addressList.addNewAddress();
            },

            _onSelectTab: function (tab) {
                //Tab changed
                //console.log(tab);
                var page = tab.detail.item;
                if (page.id === 'deliveryPage') {
                    // refresh google map because it's been hidden
                    var gfsCheckout = this.$.gfsCheckoutWidget;
                    gfsCheckout.CheckMapIsReset();
                }
//                console.log('page selected', page);
            },

            showGeneralFault: function() {
                //return; //Debug
                this.fire('generalFault');
                this.$.generalFault.open();
            },

            hideGeneralFault: function () {
                this.$.generalFault.close();
            },
        });

        function p4mDroppointToGfsDroppoint(item) {
           var gfsAddress = {
                droppointId: item.dropPointId,
                droppointDescription: item.companyName,
                geoLocation: {
                                    
                    postCode: item.postCode,
                    addressLines: [item.companyName, item.street1],
                    town: item.city,
                    coordinates: {
                        latitude: item.latitude,
                        longitude: item.longitude
                    },
                    countryCode: item.countryCode,
                    county: "",
                    directions: item.specicalInstructions
                },
                providerId: item.dropPointProviderId,
                providerLogo: "https://s-media-cache-ak0.pinimg.com/avatars/pelithepenguin_1453991623_140.jpg",
                providerName: item.label
            };
            return gfsAddress;

        }

        function p4mAddressToGfsAddress(item) {
            if (!item) return false
            else {

                var gfsAddress = {
                    id: item.id,
                    CountryCode: {
                        Code: item.countryCode || "GB",
                        Encoding: "ccISO_3166_1_Alpha2"
                    },
                    Postcode: item.postCode || "",// "SO40 7JF", //ViewBag.InitialPostCode,
                    town: item.city,
                    addressLineCollection: [item.street1],
                    name: item.label
                };
                if (item.latitude && item.longitude) {
                    gfsAddress.lat = item.latitude,
                    gfsAddress.lng = item.longitude
                }
                return gfsAddress;
            }
        }

        function hashThis(value) {
            //return Math.random().toString();
            return value.split("").reverse().join("")
        }
    </script>
</dom-module>
